

# 프로토타입 개념



#### 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.





## 객체지향 (object oriented programming)

object 객체는 사물, oop는 사물을 생산하는 방법, 물건을 효율적으로 만드는 방법이라 생각하면 편하다.







ES6에서 클래스가 도입되긴 했지만, 다른 언어에서 사용되는 클래스와는 차이가 있다. 

-> **자바스크립트가 프로토타입 기반 언어(prototype based language)이기 때문!**





### 그래서 프로토타입?

- 자바스크립트에는 클래스라는 개념이 없다. (new를 활용해 클래스 흉내)
- 프로토타입을 이용해 상속을 흉내 



자바스크립트에서는 **primitive(원시 값)을 제외**하고는 **모두 객체**이기 때문에 생긴다.

```
let bar = "baz";
console.log(bar);        // baz
bar.toUpperCase();
console.log(bar);        // baz
console.dir(bar);		// baz


// 원시 값
let foo = 5;

// 원시 값을 변경해야 하는 함수 정의
function addTwo(num) {
   num += 2;
}
// 원시 값을 인수로 전달해 첫 번째 함수를 호출
addTwo(foo);
// 현재 원시 값 반환
console.log(foo);   			// 5

```



### **그리고 객체는 함수로부터 시작된다.**



![image](https://user-images.githubusercontent.com/61727311/128637820-70a1bc2b-1ac7-41da-8e14-ddd344a91f61.png)





그렇기 때문에, 

```
let number1 = [1, 2, 3];
// 다음과 같이 해석된다.
let number1 = new Array(1, 2, 3);
```





```js
function Person() {}			// 함수
let park = new Person();		// 객체 생성
```





함수를 정의하여 생성될때 prototype object가 같이 생성되고,

생성된 prototype object는 (constructor와 \__proto__  ) 속성을  가지고 있다.

- constructor는 Prototype Object와 같이 생성되었던 함수 (생성자)를 나타내고
- \__proto__는 Prototype Link 이다.





위 **prototype object**를 통하여 상속을 흉내낼수 있다!

![image](https://user-images.githubusercontent.com/61727311/128637831-c8c517ca-5bf9-41f0-ab5e-334a028d63ed.png)

[출처 https://velog.io/@wmc1415/Javascript-Prototype%EC%9D%B4%EB%9E%80 ]







```
// 함수는 기본적으로 prototype 프로퍼티가 있음
function func() {}
func.hasOwnProperty('prototype') // true

// 일반 객체는 prototype 프로퍼티가 없음
const obb = {
    Hello : function() {
        alert("Hellllloo")
    }
};

obb.hasOwnProperty('prototype'); // false
obb.Hello.hasOwnProperty('prototype'); // true
```



![image](https://user-images.githubusercontent.com/61727311/128637844-902b238b-689f-4d50-8f87-fd044719283a.png)





```
function Person(name) {
  this.name = name;
}

var foo = new Person('Lee');

// Person() 생성자 함수에 의해 생성된 객체를 생성한 객체는 Person() 생성자 함수이다.
console.log(Person.prototype.constructor === Person); //true

// foo 객체를 생성한 객체는 Person() 생성자 함수이다.
console.log(foo.constructor === Person); //true

// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.
console.log(Person.constructor === Function); //true
```







### 프로토타입 체인



![image](https://user-images.githubusercontent.com/61727311/128637847-85dfbf43-9c92-4cba-9bd2-1038551b6b9b.png)

​														[https://poiemaweb.com/js-prototype]



#### 문제



```js
function Person(name) {
	this.name = name;
}
const foo = new Person("Hi");


const people = function(name) {
	this.name = name;
}

console.log(foo.constructor === Person); 				
console.log(foo.constructor === Function ); 			
console.log(foo.constructor.constructor === Function);	

console.log(people.constructor === Function);
console.log(Person.prototype === foo.__proto__)  
```











#### 답



```
// true
// false
// true
// true
// true
```







# 그래서 왜 prototype을 쓰는가?



### 간단하게

```
function Person(name, first, second){
    this.name = name,
    this.first = first,
    this.second = second,
    this.sum = function(){
        return this.first + this.second;
    }
}

let kim = new Person('kim',10,20);
let park = new Person('park', 10, 50);

console.log(kim.sum()); // 30
console.log(park); //Person {
  name: 'kim',
  first: 10,
  second: 20,
  sum: [Function (anonymous)]
}

```

자료의 갯수가 매우 많아졌다고 생각해보자.

그 안에서 몇개의 메서드나 객체를 사용하고 싶은데 위의 코드에서는

 Person이라는 생성자가 실행 될때마다, sum이라는 함수가 생성된다. 

즉, **함수생성 시간**이 들고, **메모리 낭비**를 초래한다.



```
function Person(name, first, second){
    this.name = name;
    this.first = first;
    this.second = second;
}
Person.prototype.sum = function(){
    return this.first + this.second + this.third;
}

let kim = new Person('kim',10,20);
let park = new Person('park', 10, 50);

console.log(kim.sum()); // 30
console.log(park); // Person { name: 'park', first: 10, second: 50 }
```



prototype을 사용했기에 console.log(park)을 해도 sum 메서드가 나오지 않는다.



