# 이벤트 위임

<br>

## 이벤트 위임

<br>

### **이벤트 위임이란?**

<br>

`이벤트 위임`은 동적으로 생성되거나 삭제되는 DOM 요소들이 있을 때

각각 요소들마다 `addEventListener()`를 사용하여 이벤트 리스너를 등록하는 것이 아니라

요소들을 감싸고 있는 부모에만 이벤트 리스너를 등록하여 자식 노드들의 이벤트를 제어할 수 있는 방법이다.

이벤트 위임을 이해하기 위해 선수지식이 필요한데 바로 `이벤트 버블링(Event Bubbling)` 이다.

이벤트 버블링을 간단히 정의해 보면 다음과 같다.

<br>

### 이벤트 버블링

<br>

> 어떠한 요소에 이벤트가 발생했을 때 이벤트가 `최상위의 요소(document)`를 만날 때까지 전달되는 특성이다.

<br>

이렇게 글로만 봤을 때 아직 와닿지 않을 수도 있다. 바로 코드로 확인해보자

```html
<html>
  <body>
    <main class="main">Main 입니다.</main>

    <footer>Footer 입니다.</footer>
    <script src="main.js"></script>
  </body>
</html>
```

```js
document.addEventListener('click', e => {
  console.log('document 클릭!');
});

const $html = document.documentElement;
$html.addEventListener('click', e => {
  console.log('html 클릭!');
});

const $body = document.body;
$body.addEventListener('click', e => {
  console.log('body 클릭!');
});

const $main = document.querySelector('.main');
$main.addEventListener('click', e => {
  console.log('main 클릭!');
});

const $footer = document.querySelector('footer');
$footer.addEventListener('click', e => {
  console.log('footer 클릭!');
});
```

위 코드를 보면 main, footer, body, html, document에 모두 `click 이벤트`가 등록되어 있다.

이 상태에서 main 영역을 클릭하면 어떤 일이 발생할까?

콘솔을 보면 다음과 같이 출력된다.

```
main 클릭!
body 클릭!
html 클릭!
document 클릭!
```

main 영역만 클릭하였는데 main의 `상위 요소`들에 등록된 이벤트가 실행된 것을 볼 수 있다.

이러한 특징이 바로 `이벤트 버블링` 이다.

<br>

> **주의할 점** : `거의 모든` 이벤트가 버블링 되지만 버블링 되지 않는 이벤트들도 있다.
> [https://www.w3.org/TR/uievents](https://www.w3.org/TR/uievents)

> event.stopPropagation()을 사용하여 이벤트 버블링을 강제로 막을 수도 있다.

<br>

### 이벤트 캡처링

<br>

이벤트 버블링과 반대 방향(상위 → 하위)으로 이벤트가 전파되는 방법이다.

버블링과는 다르게 캡처링은 `addEventListner`에 별도로 옵션( `true` 혹은 `{ capture: true }` )을 지정해야 사용할 수 있다. (기본값은 false 이다.)

```js
document.addEventListener(
  'click',
  e => {
    console.log('document 클릭!');
  },
  true
);

const $html = document.documentElement;
$html.addEventListener(
  'click',
  e => {
    console.log('html 클릭!');
  },
  true
);

const $body = document.body;
$body.addEventListener(
  'click',
  e => {
    console.log('body 클릭!');
  },
  true
);

const $main = document.querySelector('.main');
$main.addEventListener(
  'click',
  e => {
    console.log('main 클릭!');
  },
  true
);
```

이번에 Main 영역을 클릭하면 어떻게 될까?

```js
document 클릭!
html 클릭!
body 클릭!
main 클릭!
```

콘솔을 보면 `버블링과 반대`로 출력된 것을 볼 수 있다. **(캡처링은 자주 쓰이진 않는다고 한다.)**

다시 본론으로 돌아와서 이벤트 위임은 `이벤트 버블링`을 활용한 방법이다.

이벤트 위임을 사용하지 않은 방법과 사용한 방법을 비교해 보면서 이해해 보자.

<br>

## 이벤트 위임을 사용하지 않은 방법

<br>

```html
...생략

<ul class="todo-list">
  <li class="todo-item" data-id="1">일어나</li>
  <li class="todo-item" data-id="2">밥먹어</li>
  <li class="todo-item" data-id="3">공부해</li>
  <li class="todo-item" data-id="4">복습해</li>
</ul>

...생략
```

이러한 리스트가 존재하고 각 항목에 이벤트를 등록해야 한다.

아래 코드와 같이 생각해 볼 수 있다.

```js
// Todo 아이템들
const $todoItems = document.querySelectorAll('.todo-item');

// loop를 돌면서 각 항목에 이벤트 등록
$todoItems.forEach($item => {
  $item.addEventListener('click', e => {
    const { target } = e;
    console.log(target);
  });
});
```

이 방법엔 몇 가지 문제가 존재한다.

1. 항상 감지하고 있지 않는 이상 동적으로 등록되는 요소에는 이벤트가 등록되지 않는다.

   ```js
   const $todoList = document.querySelector('.todo-list');
   const $newTodoItem = document.createElement('li');

   $newTodoItem.classList.add('todo-item');
   $newTodoItem.textContent = '자라';

   $todoList.appendChild($newTodoItem);
   ```

2. 요소가 많아질 경우 메모리 사용량이 많아질 수 있고, 누수가 발생할 수 있다.

<br>

## 이벤트 위임을 사용한 방법

<br>

```js
// 아이템을 감싸고 있는 상위 요소
const $todoList = document.querySelector('.todo-list');

// 상위 요소에 이벤트 바인딩
$todoList.addEventListener('click', e => {
  const { id } = e.target.dataset;
  console.log(`${id}가 클릭되었습니다!`);
});

// 동적으로 데이터를 생성하더라도 버블링으로 인해 정상동작
const $newTodoItem = document.createElement('li');

$newTodoItem.classList.add('todo-item');
$newTodoItem.textContent = '잠자';
$newTodoItem.dataset.id = '5';

$todoList.appendChild($newTodoItem);
```

이벤트 위임을 사용했을 때의 장점은 다음과 같다.

1. 상위 요소에 이벤트를 등록하기 때문에 하위 요소가 동적으로 추가, 삭제되어도 크게 신경 쓰지 않아도 된다.
2. 메모리 사용량을 줄일 수 있다.

<br>

## 정리

1. 여러 요소를 감싸고 있는 상위(부모) 요소에만 이벤트를 등록한다.
2. event.target을 사용해서 실제 이벤트가 발생한 요소를 찾는다.
3. 이벤트의 흐름 : 캡처링 → 타겟 → 버블링

<br>

![image](https://user-images.githubusercontent.com/52060742/131235520-0a11ffbe-9d74-4b6f-8d1e-78d7fcc815c8.png)

이미지 출처 - [https://ko.javascript.info/bubbling-and-capturing](https://ko.javascript.info/bubbling-and-capturing)

> React 같은 경우 내부적으로 이벤트 위임을 사용한다.

<br>

## 참조

<br>

[https://ui.toast.com/weekly-pick/ko_20160826](https://ui.toast.com/weekly-pick/ko_20160826)

[https://ko.javascript.info/bubbling-and-capturing](https://ko.javascript.info/bubbling-and-capturing)

[https://velog.io/@yesdoing/이벤트-위임Event-Delegation의-구현](
