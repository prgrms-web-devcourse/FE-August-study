# JS의 메모리 관리 '가비지 컬렉션'

# JS의 메모리 관리

## 기본 메모리 생명 주기

1. 필요한 메모리를 **할당**합니다.
2. 할당된 메모리를 **사용**합니다. (읽기/쓰기)
3. 해당 메모리가 필요 없어지면 **해제**합니다.

2번은 모든 프로그래밍 언어에서 공통적으로 사용되는 부분입니다.
하지만 **1번**과 **3번**은 저수준과 고수준 언어에서 큰 차이가 납니다.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
	int num1 = 20; // 변수선언
	int *numPtr1; // 포인터 선언

	numPtr1 = malloc(sizeof(int)); // 4바이트만큼 동적 메모리 할당

	printf("%p\n", numPtr1); // 변수 num1의 메모리 주소 출력

	free(numPtr1); // 동적으로 할당한 메모리 해제

	return 0
}
```

```jsx
var n = 123; // 정수를 담기 위한 메모리 할당
var s = "azerty"; // 문자열을 담기 위한 메모리 할당

var o = {
  a: 1,
  b: null,
}; // 오브젝트와 그 오브젝트에 포함된 값들을 담기 위한 메모리 할당

// (오브젝트처럼) 배열과 배열에 담긴 값들을 위한 메모리 할당
var a = [1, null, "abra"];

function f(a) {
  return a + 2;
} // 함수를 위한 할당(함수는 호출 가능한 오브젝트이다)

// 함수식 또한 오브젝트를 담기위한 메모리를 할당한다.
someElement.addEventListener(
  "click",
  function () {
    someElement.style.backgroundColor = "blue";
  },
  false
);
```

- 자바스크립트는 값을 선언하거나 함수를 호출할 때 **자동으로 메모리를 할당**합니다.
- 하지만, C언어의 `free()`처럼 할당된 메모리가 더 이상 필요없을 때 어떻게 해제할까요?

그러고보니, JS를 쓰면서 그런 걸 생각해본 적이 없네요.

# 가비지 컬렉션

- JS는 그래서 **Garbage Collection**이라는 자동 메모리 관리 형식을 사용합니다.
- 엔진 내에서 끊임없이 동작하고 모든 객체를 모니터링하고 있습니다.

그러면 GC는 어떻게 쓸모없는 것들을 구분할까요?

## 도달 가능성 Reachability

- 이것이 바로 JS가 메모리 관리를 수행하는 기준입니다.
- **어떻게든 접근하거나 사용할 수 있는 값**을 의미합니다.
  - 루트 Root
    - 현재 함수의 지역변수와 매개변수
    - 중첩 함수의 체인에있는 함수에서 사용되는 변수와 매개변수
    - 전역변수 등
  - 루트가 참조하는 값이나 체이닝으로 루트에서 참고할 수 있는 값
    - 전역 변수에 저장된 객체 → 그 객체의 프로퍼티가 참조하는 또 다른 객체

```jsx
let user = { name: "Yunji" }; // user에는 객체 참조 값이 저장

user = null; // { name: "Yunji" } 라는 객체가 도달할 수 없는 상태가 되고 메모리에서 삭제됨
```

### 표시하고 쓸기 알고리즘 mark-and-sweep

- 가비지 컬렉션의 기본 알고리즘입니다.

  1. 가비지 컬렉터는 루트`root`정보를 수집하고 이를 mark(기억)합니다.
  2. 루트가 참조하고 있는 모든 객체를 방문하고 이를 mark합니다.
  3. mark된 모든 객체에 방문하고, 그 객체들이 참조하는 객체도 mark합니다.
     한번 방문한 객체를 다시 방문하는 일은 없습니다.
  4. 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.

     ![[week2]JavaScript_GarbageCollection/Untitled.png]([week2]JavaScript_GarbageCollection/Untitled.png)

  5. mark되지 않은 모든 객체를 메모리에서 삭제합니다.

     ![[week2]JavaScript_GarbageCollection/Untitled%201.png]([week2]JavaScript_GarbageCollection/Untitled%201.png)

### 한계점

- 하지만 이러한 알고리즘에는 **'순환 참조'** (서로 다른 오브젝트가 서로를 순환하게 참조) 문제가 발생할 수 있습니다.

  ```jsx
  function f() {
    var o1 = {};
    var o2 = {};
    o1.p = o2; // o1은 o2를 참조함
    o2.p = o1; // o2는 o1을 참조함. 이를 통해 순환 참조가 만들어짐.
  }

  f();
  ```

  ![Untitled]([week2]JavaScript_GarbageCollection/Untitled%202.png)

  - `o1`과 `o2`는 함수 호출 뒤에 스코프를 벗어나게 되므로, 실질적으로는 쓸모가 없게 됩니다.
  - 하지만 모든 객체가 **서로를 참조**하고 있어 가비지 컬렉션이 어느 객체도 삭제하지 못합니다.
  - 순환 참조 문제가 발생하면 메모리 해제가 발생하지 않아 **메모리 누수**가 생기게 됩니다.

    - 메모리 누수?

      컴퓨터 프로그램이 필요하지 않은 메모리를 계속 점유하고 있는 현상

- 그리고 사람이 판단하는 것이 아니기에, 어떤 메모리를 해제하는 것이 올바른지에 대해
  해당 알고리즘이 내리는 결정이 **정확하다고 말할 수 없습니다**.
- 하지만 아직까지 JS에서는 개발자가 직접 메모리에서 삭제하도록 명시하는 기능은 **없습니다**.

## JS의 가비지 컬렉션 최적화 기법

1. 세대별 수집
   - 객체를 **새로운 객체**와 **오래된 객체**로 구분합니다.
   - 객체의 상당수는 생성된 이후 제 역할을 빠르게 수행하고 없어집니다. → 새로운 객체
   - 일정 시간 이상 살아남은 객체는 가비지 컬렉터가 덜 감시합니다. → 오래된 객체
2. 점진적 수집
   - 자바스크립트 엔진은 **가비지 컬렉션을 분리**하고, 각 부분을 별도로 수행합니다.
   - 작업을 분리하면 당연히 수행시간은 더 빨라지겠죠?
3. 유휴 시간 수집
   - 실행에 주는 영향을 최소화하기 위해, **CPU가 유휴 상태**일 때에만 가비지 컬렉션을 실행합니다.

엔진마다 다른 가비지 컬렉션 알고리즘과 최적화 기법이 있습니다.

# 참고 링크

- MDN

  [자바스크립트의 메모리관리 - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)
