
# 1. 프로세스(Process)
##   프로세스? 프로그램?
프로세스와 스레드를 비교하기 이전에,  `프로세스`라는 단어와 `프로그램`이라는 단어는 우리에게 익숙한 단어이다. 하지만 이 둘의 정의와 차이점을 말하라고 하면은 선뜻 말하기 어려울 것이다. 


> ### 프로그램 
: 보조 기억장치(하드디스크, SSD)에만 존재하며 파일이  메모리에는 올라가 있지 않은 정적인 상태

![](https://images.velog.io/images/kimin3004/post/7fc68376-5a19-4f0c-b987-09da0b41b1a1/image.png)
#### 메모리에 올라가 있지 않다?
아직 운영체제가 프로그램에게 독립적인 메모리 공간을 할당해주지 않았다는 뜻이다. 모든 프로그램은 운영체제가 실행되기 위한 메모리 공간을 할당해 줘야 실행될 수 있다.
> 즉, 프로그램은 저장 장치에 저장되어 실행되기만을 기다리는 코드 묶음이다.

##### ex) 윈도우의 `*.exe`,  MacOS의 `*.dmg` 등등 

![](https://images.velog.io/images/kimin3004/post/f9d4b460-b328-4571-95cd-d46a05ee97fb/image.png)

이런 **프로그램**은 혼자서 움직일 수 없다. 사용자가 이런 프로그램을 클릭하여 실행하게 되면, 이 프로그램의 명령어와 정적 데이터가 메모리에 적재되며 비로소 동작할 수 있는 **프로세스**가 된다.


> - **프로그램** : 파일 시스템에 존재하는 실행 파일<br>
> - **프로세스** : 컴퓨터에서 실행되고 있는 컴퓨터 프로그램

<br>
<br>

## 프로그램에서 프로세스로
사용자가 위의 실행파일들을 클릭해서 실행하게 되면, 운영체제가 그 프로그램을 실행시켜야 한다. 프로그램을 실행시키는 프로세스를 실행주체, 인스턴스(instance)라고도 하며, 하나의 프로그램을 실행시키는 프로세스는 여러개로 이루어질 수 있다

![](https://images.velog.io/images/kimin3004/post/20268d8e-90f4-4f16-a19b-9fdbc2bebbb7/image.png)

##### 이렇게 하나의 실행파일(프로그램)을 가지고 있는 인터넷 익스플로러를 두개를 실행한다면 프로세스 상에서는 인터넷 익스플로러가 2개 사용되고 있는 것이다. 
 

#### 프로그램이 실행되어 프로세스가 메모리에 올라가며, 메모리는 4가지 영역으로 나뉘게 된다.
- **`Code`** : 실행 명령을 포함하는 코드들
- **`Data`** : Static 변수 or Global변수
- **`Stack`** : 지역변수, 매개변수, 반환값 등등 일시적 데이터
- **`Heap`** : 동적 메모리 영역

![](https://images.velog.io/images/kimin3004/post/80de5ce4-ba79-473d-bcbb-75219af19d04/image.png)
##### [이미지 출저 : https://velog.io/@raejoonee ](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)

운영체제는 안정성을 위해 각각의 프로세스에게 독립된 메모리를 할당해주기 때문에 다음과 같은 특징이 있다. 
* 프로세스는 기본적으로 다른 프로세스의 변수나 자료에 접근할 수 없도록 분리되어 있다. 
* 각 프로세스는 **프로세스 간 통신** (Interprocess Communication, **IPC**)이라는 조금은 번거로운 작업을 통해서만 정보 공유가 가능하다.
##### ex) 파이프, 파일, 소켓 등을 이용한 통신 방법 이용

<br>

이러한 프로세스의 특성으로 인해, 만일 우리가 (단일 스레드를 가진) 프로세스들만을 가지고 여러 프로그램들을 실행한다면 `컨텍스트 스위칭(Context Switching)`이라는 비용이 발생하게 된다.

이는 여러 프로그램이 동시에 실행되는 것처럼 보이게 하기 위해 시분할로 실행단위가 cpu를 점유하는 것을 뜻한다. 


![](https://images.velog.io/images/kimin3004/post/b906e26c-b43e-45bf-b6da-e16c9e063dc8/image.png)
> **컨텍스트 스위칭 (Context Switching)** 
:  다음 프로세스가 실행되어야 할 때 각 프로세스들은 메모리를 공유하지 않기 때문에, 기존의 프로세스의 상태(레지스터 값)을 저장하고 다음 프로세스의 상태(레지스터 값)을 교체하는 작업 => 캐쉬 메모리를 초기화!

이러한 프로세스의 한계로 더 작은 실행 단위의 필요성이 생기게 되었고, **경량화된 프로세스(Light Weight Process)** 버전인 **스레드(Thread)**가 등장하게 되었다. 
<br>



-----
# 2. Thread(스레드)
스레드(thread)는'한 가닥의 실'이라는 사전적 의미를 가지고 있다.  이는 한 가지 작업을 실행하기 위해 순차적으로 실행할 코드를 실처럼 이어 놓은데서 유래한 이름이다. 스레드는 하나의 코드 실행 흐름으로, 한 프로세스에 스레드가 두 개라면 두 개의 코드 실행 흐름이 생기는 것을 의미한다.


스레드는 프로세스 내부에 위치하고 있으며,  각각 **`Stack`**만 따로 할당을 받고 **`Code`**, **`Data`**, **`Heap`** 영역을 공유한다.
~~(각각의 스택을 가지고 있는 함수라고 생각하면 이해하기가 쉽다. )~~

![](https://images.velog.io/images/kimin3004/post/8f1eb8c0-93b5-4813-8cf9-94ad4bc5a46c/image.png)
##### [이미지 출저 : https://velog.io/@raejoonee ](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)


* 하나의 프로세스에 여러개의 스레드가 생성가능하다.

* 스레드들은 동시에 실행이 가능하다.

* 프로세스 내부에 있으므로, 프로세스의 데이터에 접근이 가능하다. 

**`Code`**, **`Data`**, **`Heap`** 과 같이 공유되는 자원이 있기 때문에, 아까처럼 컨텍스트 스위칭이 일어날 때, 캐싱 적중률이 올라가며 데이터 액세스 속도가 향상된다.
<br>

<br>

### 응용 프로그램(application)? 프로세스?

> 응용 프로그램은 여러 개의 프로세스(프로그램)으로 이루어 질 수 있다.
간단한 C/C++로 만들어진 단순한 프로그램이 아닌 이상, 하나의 응용 프로그램은 여러 개의 프로세스(프로그램)이 상호작용을 하며 실행될 수 있다.  

<br>


-----
# 3. 멀티 프로세스, 멀티 스레드
**멀티 프로세스**와 **멀티 스레드**는 '동시에 두 가지 이상의 루틴을 실행 할 수 있는 역할'을 한다는 점은 같다. 위에서 프로세스와 스레드의 개념을 이해한다면 간단하게 정리가 가능하다. 


> ### 멀티 프로세스
: 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행하는 것

![](https://images.velog.io/images/kimin3004/post/a05819b4-fc16-4674-9f96-3c5526d3d941/image.png)
##### [이미지 출저 : https://velog.io/@sehrltjr/Thread ](https://velog.io/@sehrltjr/Thread)

#### 장점
- 메모리 침범 문제를 OS 차원에서 해결한다.

- 여러 자식 프로세스 중 하나에 문제가 발생하여도 그 프로세스만 타격, 확산되지 않는다.

#### 단점

- 각 프로세스가 독립된 메모리 영역 (Code, Data, Heap, Stack)을 가지고 있기 때문에 작업량이 많아지면  `컨텍스트 스위칭 (Context switching)`으로 인해 `오버헤드`가 발생한다.

- 프로세스 간의 복잡한 통신`(IPC)` 가 필요하다. 

 `오버헤드` : 어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리

<br>

---
하나의 프로세스 내에서 여러 스레드로 나뉘어 실행단위가 나뉘어 지면, **멀티 스레드**가 된다.

> ### 멀티 스레드(Multi Thread) 
: 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하게 하는 방식

![](https://images.velog.io/images/kimin3004/post/5519cfe9-9b37-422e-a1f4-d0a5178c074f/image.png)
##### [이미지 출저 : https://velog.io/@sehrltjr/Thread ](https://velog.io/@sehrltjr/Thread)

#### 장점 
* Context Switching 에 대한 `오버헤드`가 줄어 든다.
* 메모리 공유로 인한 시스템 자원 소모가 줄어든다. (IPC 과정 필요 X)
* 응답시간이 단축 된다.

#### 단점

- 서로 다른 스레드가 Stack을 제외한 메모리 공간을 공유하기 때문에 **동기화 문제**가 발생할 수 있다. 
- 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받게된다.

![](https://images.velog.io/images/kimin3004/post/01093cb2-5acb-47d7-b630-477ea4834189/image.png)

<br> 

- 이로 인해 주의 깊은 설계가 필요하며 디버깅이 까다로울 수 있다. 

<br>
<br>

### 운영체제의 사용목적에 따라 달라진다. 

![](https://images.velog.io/images/kimin3004/post/ee3161ba-0bd1-4fc1-954f-8efc75a94cf9/image.png)

 운영체제는 위 그림 처럼 단일 또는 여러 개의 프로세스와 스레드를 가지도록 설계 될 수 있다. 이는 즉, 운영체제의 사용 목적에 따라 프로세스와 스레드를 설계를 하면 된다는 의미이다. 
현재 우리가 사용하는 윈도우 , 리눅스, 유닉스, 맥 같은 운영체제는 멀티 프로세스, 멀티 스레드(4번째) 설계되어 있다. 이는 복잡성이 높다는 특징이 있기 때문에, 초소형 시스템 같은 경우에 좀 더 단순한 구조로 설계 되는 것이 효율적일 것이다. 
  
<br>
<br>

##### 참고:<br>https://www.youtube.com/watch?v=1grtWKqTn50&t=714s<br>https://bowbowbow.tistory.com/16<br>[https://velog.io/@raejoonee/](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)<br>https://you9010.tistory.com/136<br>https://magi82.github.io/process-thread/<br>https://yolojeb.tistory.com/9<br>[https://m.blog.naver.com/PostView.naver](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=duehd88&logNo=20183434063)<br>[https://velog.io/@nnnyeong/OS](  https://velog.io/@nnnyeong/OS-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%A9%80%ED%8B%B0%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%86%B5%EC%8B%A0)