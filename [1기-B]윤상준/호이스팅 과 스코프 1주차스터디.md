# 호이스팅 과 스코프

## 호이스팅(Hoisting)

<img src="https://media.vlpt.us/images/alajillo/post/75539bcd-aed4-4cbb-8e56-4a606b948210/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85.png">
호이스팅을 사전적으로 정의하자면 변수가 선언되었을때 그 변수가 코드의 가장 최 상단에서 선언된 것처럼 행동하는 것입니다. 컴퓨터의 경우 위에서 아래로 왼쪽에서 오른쪽으로 코드를 읽어갑니다. 그런데 변수를 선언도 하기전에 변수를 호출하는 경우에는 컴퓨터 입장에서 변수의 정체를 모르기때문에 오류가 나야하지만 자바스크립트에서는 오류가 나지 않는 경우가 있습니다. 이를 호이스팅이 발생하였다고 합니다.

위에그림을 보시면 hoisting2가 선언되기도 전에 hoisting2를 호출하여 출력했더니 오류는 나지 않지만 전혀 예상치못한 값인 'undefined'가 출력되었습니다. 그 이유는 변수의 생성과정을 보면 쉽게 알수 있습니다.

### 변수의 생성과정

변수의 생성 과정은 총 3가지로 이루어집니다.

> <b>1. 변수 선언</b><br><b>2. 변수 초기화</b><br><b>3. 변수 값 할당</b>

<img src="https://media.vlpt.us/images/alajillo/post/7eb41bb7-7a19-4fd6-bcb1-79fe93702639/let%EA%B3%BCvar%EC%9D%98%20%EC%B0%A8%EC%9D%B4%EC%A0%90.png">

왼쪽의 var로 선언됬을 경우를 먼저 살펴보겠습니다. var를 이용하여 선언하게 될경우 자바스크립트의 평가과정에서 호이스팅이 발생합니다. 여기서 평가과정이란 코드를 실행하기전에 변수들을 위한 렉시컬 환경을 구성하는 과정입니다. 이는 밑에서 더 자세히 다루겠습니다.

호이스팅이 되어서 var hoisting2는 코드의 최상단으로 이동합니다.(실제로 이동하는 것은 아닙니다) 그뒤 값이 비어있는 hoisting2에 undefined라는 값을 임시로 할당해줍니다. 이를 초기화 과정이라고 합니다. 그뒤 변수가 선언된 부분을 만나게 되면 그때 우리가 의도한 값을 할당하여 변수를 자유롭게 사용할수 있습니다.

그렇기 때문에 console.log(hoisting2)를 만났을때 값이 할당되기전에 초기화된 'undenfined'라는 값이 출력된겁니다.

이제 반대로 ES6문법인 let으로 변수를 선언할 경우는 어떻게 되는지 살펴보겠습니다. let의 경우에는 변수 선언 전에 호출할 경우 오류가 나기때문에 호이스팅이 안된다고 생각할수 있습니다. 저 또한 그렇게 이해를 하고 있었습니다. 하지만 let도 호이스팅이 발생합니다. var와의 차이점 때문에 발생을 안하는 것처럼 작동한것입니다.

let으로 선언될 경우 초기화 과정이 없습니다. 그렇기 때문에 임시로 들어갈 메모리조차 없기 때문에 변수가 선언되기전에는 변수를 호출할 경우 오류가 발생합니다. 이 때 let으로 선언된 변수의 스코프범위(블록단위)의 최상단부터 let으로 변수가 선언될때까지의 영역을 TDZ(Temporal Dead Zone)이라고 합니다. 이 TDZ영여안에서 호출한 경우 에러가 발생합니다.

<img src="https://media.vlpt.us/images/alajillo/post/2237943f-177d-4091-945f-12291bbd13a3/let%20%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85%20%EC%A6%9D%EB%AA%85.png">

만약 let이 호이스팅이 발생안하다고 가정했을때 전역스코프에 있는 x가 출력되어야 하지만 실행하게되면 오류가 발생합니다. 중괄호로 감싸져 있는 범위가 let의 스코프범위입니다. 그렇기때문에 중괄호 안 최상단에 let 호이스팅이 발생하였고 이로 인해 TDZ는 중괄호 최상단부터 let x = "지역변수"바로 위에 줄까지가 형성이 되고 오류가 발생했습니다. 오류의 내용을 살펴보면 x가 초기화 되기전까지 접근을 못한다고 나옵니다. 위에서 말했던 것처럼 let으로 선언된 경우 호이스팅될때 초기화를 해주지 않기때문에 이런 오류메세지가 나오는 것을 볼수 있습니다.

## 스코프

<img src="https://media.vlpt.us/images/alajillo/post/33568dfa-4503-43f5-bf7d-5203d97201e8/%EC%8A%A4%EC%BD%94%ED%94%84.png">

스코프는 변수가 유효한 범위를 뜻합니다. 위에 그림에서 보면 outer함수 안에 inner함수가 있습니다. var의 경우 함수스코프를 가지고 이는 함수내부에서 var로 선언된 변수는 함수내부에서만 유효하고 만약 if와 for같은 경우에는 그 밖에서도 유효하다는 뜻입니다. let의 경우 블록스코프를 가지고 있으며 이는 if,for,while,함수 등 중괄호를 이용하는 제어문, 반복문, 함수 안에서 let으로 선언된 변수는 이 안에서만 유효하다는 뜻입니다. inner함수에서 선언된 scope 변수는 inner함수의 밖에서 호출할 경우 사용할수 없습니다. 하지만 반대로 outer함수에서 선언된 scope 변수는 inner함수 내부에서도 호출이 가능합니다. 이유는 outer함수 범위에 inner함수 영역이 포함되어있기 때문에 가능합니다.

```javascript
let x = 1;
function inner() {
  console.log(x);
}

function outer() {
  let x = 9;
  inner();
}
outer(); // 1 ?? 9
```

위에 코드의 실행결과값을 생각해보면 1이 되는것도 말이 되고 9가 되는것도 말이됩니다. 전역스코프에서는 x의 값이 1로 선언되었습니다. 그리고 전역스코프에서 inner함수가 선언되었습니다. 그리고 outer함수안에서 x의 값을 9로 선언하고 inner함수를 호출합니다. 이때 inner함수는 어떤 x의 영향을 받아 호출 할까요?

두가지로 나눠볼수있습니다.

> 1. 선언되었을때를 기준으로 해야하기 때문에 선언될 당시 전역스코프에서 선언된 x의 값을 출력해야한다.
> 2. 호출하였을때를 기준으로 해야하기 때문에 호출할 당시 outer함수 내부에서 호출되었기때문에 outer함수안에서 선언된 x의 값을 출력해야한다.

두가지 상황에서 자바스크립트는 선언된 환경을 기준으로 하기때문에 실제 출력값은 전역스코프에서 선언된 x의 값인 1이 출력됩니다.

<img src="https://media.vlpt.us/images/alajillo/post/0ea4743a-e269-4566-8fe8-8f35c3be0390/%EC%8A%A4%EC%BD%94%ED%94%84%EC%B2%B4%EC%9D%B8.png">

이를 가능하게 해주는 것이 스코프 체인이라는 것입니다. 저는 위에 코드 예시를 보면서 그럼 컴퓨터는 어떻게 변수명이 같은 변수들을 스코프로 구분하는걸까 라는 생각을 많이했습니다. 아까 상단에서 자바스크립트 평가과정에서 렉시컬 환경을 구성한다고 했습니다. 위에 왼쪽그림에 있는 것이 렉시컬 환경입니다. 노란색 테이블은 하나씩 변수의 스코프단위입니다. 위에 코드를 예시로 들어보겠습니다. 전역스코프(전역객체)내부에서 x와 y 그리고 outer함수가 선언되었습니다. 이에따라 왼쪽 그림의 가장 왼쪽 테이블처럼 렉시컬 환경이 구성됩니다. 그리고 outer함수또한 같은 원리로 생성되고 그 안에 inner함수도 생성됩니다. 그리고 각자 생성된 스코프들을 이어주는 방향성을 가진 스코프체인을 형성합니다. 지금 겹치는 변수명이 x가 있습니다. outer함수에서 x를 호출할 경우 outer함수 렉시컬환경에서는 x가 없습니다. 그럼 스코프체인을 따라서 전역스코프로 올라가서 x를 찾게됩니다. 스코프체인에는 항상 상위 스코프로 올라가는 방향성을 가지기 때문에 하위 스코프로 내려가서 변수를 찾지는 않습니다. inner함수의 경우에는 x가 렉시컬 환경에 있기때문에 스코프체인을 따라 상위 스코프로 올라가지 않습니다.
