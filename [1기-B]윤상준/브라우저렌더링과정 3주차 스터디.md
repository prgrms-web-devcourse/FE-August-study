# 브라우저의 렌더링 과정

## 데이터 가져오기

브라우저의 화면을 띄우기 위해서는 우선적으로 데이터가 필요합니다.
이 데이터는 서버 혹은 저장장치에서 byte 즉 8개의 비트단위로 전송됩니다.

### 왜 byte단위로 전송되나요?

기본적으로 CPU는 바이트단위로 데이터를 처리하기 때문입니다.
그 예로 true와 false 두 값을 가지는 Boolean 데이터타입의 크기는 문자형과 같은 1byte입니다.
<img src="https://media.vlpt.us/images/alajillo/post/0460caf9-b0bd-455d-b506-d05907c137be/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-20%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%209.29.11.png">
위에 보시는바와 같이 문자형의 데이터크기와 불린형의 데이터 크기가 같습니다.
true와 false의 값만을 담는 거면 1bit로 충분할텐데 왜 1byte를 할당하는지에 대한 대답이 될수 있습니다.

## 데이터를 받아온 브라우저는 이게 뭔지 모른다

html파일을 byte단위로 데이터를 받아온 브라우저는 이게 무슨 데이터인지를 모릅니다.
<img src ="https://media.vlpt.us/images/alajillo/post/a0a90e8e-e138-4fb2-a6ce-fa688dd9faa8/byteToCharacter.png">

받아온 byte를 character 즉 문자로 변환합니다. 하지만 아직까지 브라우저는 이 텍스트파일이 무슨 뜻인지 잘 모릅니다. 그렇기 때문에 몇가지 단계를 더 거쳐야합니다.

<img src ="https://media.vlpt.us/images/alajillo/post/3c0065f7-e648-4f54-8ce6-b4608fe721a0/byteToDOM%20Tree.png">
먼저 html문서가 의미하는 뜻을 해석하기 위해서 Token으로 나눠어줍니다.

```javascript
const text = "<div>hello</div>";
const token = tokenization(text); //임의의 함수
console.log(token); // [{openTag : true,type : divTag,attribute : null, content : hello, closeTag : true}]
```

정확하지는 않지만 이런식으로 태그를 기준으로 잘게 나누어줍니다.
이 토큰을 가지고 노드형식으로 다시 변환해줍니다. 이 노드들을 모아서 Tree형태의 자료구조를 만들어줍니다.
이를 DOM 트리를 만들어줍니다.
이제 브라우저가 이해할수 있는 DOM(DocumentObjectModel)구조가 완성되었습니다.
이렇게 해당프로그램에서 이해할수있도록 변환시키는 과정을 Parse라고 합니다.
<img src="https://media.vlpt.us/images/alajillo/post/b4e48d3a-ebfd-430b-9abe-26d534f1199c/DomTree.png">

## CSS 가져오기

토큰화를 하면서 CSS 파일에 위치가 담긴 link태그를 만나게됩니다.
이제 이를 통해서 브라우저는 CSS값을 받아옵니다.
<img src ="https://media.vlpt.us/images/alajillo/post/d20324d1-f90e-4c22-8f1a-28f91280a97b/byteToCSSOM.png">
CSS파일도 HTML파일과 마찬가지의 과정을 거쳐서 CSSOM(CSSObectModel) 구조를 만듭니다.

## Render Tree 만들기

<img src="https://media.vlpt.us/images/alajillo/post/5cb0a9e7-4faa-4b8a-9d20-d5c40965ec16/RenderTree.png">

DOM과 CSSOM을 합쳐서 Render Tree를 생성합니다. 이때 RenderTree의 역할은 화면에 그려주는 역할을 합니다.

```javascript
<div class="hide">hi</div>
<style>
.hide {
    display : none;
}
</style>
```

화면에 그려주는 역할을 하기 때문에 위에와 같이 화면에 안나오는 태그들은 RenderTree에 포함되지 않습니다.

## 크기와 위치 계산하기(LayingOut renderTree)

RenderTree를 바탕으로 브라우저 화면에 각 요소들을 어디에 그려줄것인지
크기와 위치를 계산합니다.

## 화면에 그려주기(Painting)

계산된 값을 바탕으로 화면에 그려줍니다.

<img src="https://miro.medium.com/max/624/1*srfAe9f1ryMc3qoMOASmhg.png">

많이 보던 그림입니다. 이제 이 그림을 좀더 쉽게 이해할수 있습니다.

## 자바스크립트의 등장

앞에서 나온 일련의 과정중에서 브라우저가 script태그를 만나면 모든 프로세스가 중지됩니다.

```javascript
<html>
  <head></head>
  <body>
    <div id="tag">hello</div>
    <script>
      const tag = document.getElementById('tag'); console.log(tag);
    </script>
  </body>
</html>
```

```javascript
<html>
  <head></head>
  <body>
    <script>
      const tag = document.getElementById('tag'); console.log(tag); // null
    </script>
    <div id="tag">hello</div>
  </body>
</html>
```

link태그를 만나게되면 브라우저는 CSS파일을 받아옵니다. 마찬가지로 script태그를 만나면
자바스크립트를 동작시키는데 이때 모든 프로세서는 중단 됩니다.
이는 자바스크립트의 싱글 스레드 방식과 닮아있습니다.
그렇기 때문에 script태그보다 아래에 있는 태그들은 DOM이 되지 못했기 때문에 자바스크립트 입장에서 읽을수 없습니다.
이를 방지하기 위해서 script태그의 위치가 body의 최 하단에 위치해있습니다.

### async attribute

```javascript
<script src="index.js" async></script>
```

script태그에 async라는 attribute를 붙이게 되면 parse하는 프로세스가 멈추지않고 계속 진행됩니다.
