2. - ## **ì†Œí”„íŠ¸ì›¨ì–´ ë””ìì¸ íŒ¨í„´ì´ë€?**

   ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ë°©ë²•ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë””ìì¸íŒ¨í„´(Desigin Pattern)ì€ ê³¼ê±°ì˜ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ê³¼ì •ì—ì„œ ë°œê²¬ëœ ì„¤ê³„ì˜ ë…¸í•˜ìš°ë¥¼ ì¶•ì í•˜ì—¬ ê·¸ ë°©ë²•ì— ì´ë¦„ì„ ë¶™ì—¬ì„œ **ì´í›„ì— ì¬ì‚¬ìš©í•˜ê¸° ì¢‹ì€ í˜•íƒœë¡œ íŠ¹ì • ê·œì•½ì„ ë§Œë“¤ì–´ì„œ ì •ë¦¬í•œ ê²ƒì…ë‹ˆë‹¤.** ë””ìì¸ íŒ¨í„´ì€ ì†Œí”„íŠ¸ì›¨ì–´ ì„¤ê³„ì— ìˆì–´ ê³µí†µì ì¸ ë¬¸ì œë“¤ì— ëŒ€í•œ í‘œì¤€ì ì¸ í•´ë²•ê³¼ ì‘ëª…ë²•ì„ ì œì•ˆí•˜ë©°, ì•Œê³ ë¦¬ì¦˜ê³¼ ê°™ì´ í”„ë¡œê·¸ë¨ ì½”ë“œë¡œ ë°”ë¡œ ë³€í™˜ë  ìˆ˜ ìˆëŠ” í˜•íƒœëŠ” ì•„ë‹ˆì§€ë§Œ, **íŠ¹ì •í•œ ìƒí™©ì—ì„œ êµ¬ì¡°ì ì¸ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤. ì¦‰ "íš¨ìœ¨ì ì¸ ì½”ë“œë¥¼ ë§Œë“¤ê¸° ìœ„í•œ ë°©ë²•ë¡ "ì´ë¼ê³  ìƒê°í•˜ì‹œë©´ ë©ë‹ˆë‹¤.**

   - ë˜ëŠ” íŠ¹ì • ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ 'í‹€' , 'í…œí”Œë¦¿' ì´ë¼ê³  ìƒê°í•´ë„ ë©ë‹ˆë‹¤.

     > _A pattern is a reusable solution that can be applied to **commonly occurring problems** in software design - in our case - in writing JavaScript web applications. Another way of looking at patterns are as **templates for how we solve problems** - ones which can be used in quite a few different situations_.

     \*-"**Javascript design pattern**" written by "**Addy Osmani"\***

   ë¡œí† ë‹˜ì˜ ì»´í¬ë„ŒíŠ¸ ì½”ë”©ë„ ë””ìì¸ íŒ¨í„´ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ì»´í¬ë„ŒíŠ¸ì˜ êµ¬ì„±ìš”ì†Œë„ ë””ìì¸ íŒ¨í„´ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í”íˆ ì¼ì–´ë‚˜ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë§ˆë ¨ëœ ì„¤ê³„ë„ë¼ê³  ë³´ë©´ë©ë‹ˆë‹¤.

   ë‹¨, ë””ìì¸ íŒ¨í„´ì€ ì™¸ìš°ê¸°ë³´ë‹¤ëŠ” ì–´ë– í•œ íŒ¨í„´ì´ ìˆëŠ”ì§€ ì•Œê³  ìˆ˜ë§ì€ ë””ìì¸ íŒ¨í„´ì—ì„œ ë‹¤ì–‘í•œ ì½”ë”© ë…¸í•˜ìš°ë¥¼ ìŠµë“í•˜ëŠ”ê²ƒì´ ì¤‘ìš”í•˜ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤. "ì´ ì½”ë“œì—ëŠ” ë¬´ì¡°ê±´ ì´ íŒ¨í„´ì„ ì ìš©ì‹œí‚¬ê±°ì•¼!" ì´ê²ƒì´ ì•„ë‹ˆë¼ ì—¬ëŸ¬ê°€ì§€ íŒ¨í„´ì´ ìì—°ìŠ¤ëŸ½ê²Œ ë‚´ ì½”ë“œì— ë…¹ì•„ë“œëŠ”ê²ƒì´ ì¢‹ë‹¤ê³  ìƒê°í•©ë‹ˆë‹¤.

   ## **ë””ìì¸ íŒ¨í„´ì˜ ì¢…ë¥˜**

   - **í¬ê²Œ ì„¸ê°€ì§€ íŒ¨í„´ìœ¼ë¡œ ë‚˜ë‰  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŒ¨í„´ì•ˆì— ë˜ í•˜ìœ„ íŒ¨í„´ì´ ë¬´ìˆ˜íˆ ì¡´ì¬í•˜ëŠ”ë°, ê·¸ ì¤‘ì— ë¹Œë”ë‘ ì˜µì €ë²„ íŒ¨í„´ë§Œ ê¹Šê²Œ ì•Œì•„ ë³´ë ¤ê³  í•©ë‹ˆë‹¤.**

   ### **ìƒì„± íŒ¨í„´(Creational Patterns)**

   - ê°ì²´ ìƒì„±ì— ê´€ë ¨ëœ íŒ¨í„´ì…ë‹ˆë‹¤. ê°ì²´ì˜ ìƒì„±ê³¼ ì¡°í•©ì„

     ìº¡ìŠí™”

     í•´

     íŠ¹ì • ê°ì²´ê°€ ìƒì„±ë˜ê±°ë‚˜ ë³€ê²½ë˜ì–´ë„ í”„ë¡œê·¸ë¨ êµ¬ì¡°ì— ì˜í–¥ì„ í¬ê²Œ ë°›ì§€ ì•Šë„ë¡ ìœ ì—°ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.

     - **ë¹Œë” íŒ¨í„´(Builder) :** ë³µí•© ê°ì²´ì˜ ìƒì„±ê³¼ì •ê³¼ í‘œí˜„ê³¼ì •ì„ ë¶„ë¦¬ì‹œì¼œ ë™ì¼í•œ ìƒì„±ê³¼ì •ì—ì„œ ë‹¤ì–‘í•œ í‘œí˜„ì„ ìƒì„±í•  ìˆ˜ ìˆëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

       ## Using Builder

       The most common motivation for using Builder is to simplify client code that creates complex objects. The client can still direct the steps taken by the Builder without knowing how the actual work is accomplished. Builders frequently encapsulate construction of Composite objects (another GoF design pattern) because the procedures involved are often repetitive and complex.

       Usually it is the last step that returns the newly created object which makes it easy for a Builder to participate in fluent interfaces in which multiple method calls, separated by dot operators, are chained together (note: fluent interfaces are implementation of the Chaining Pattern as presented in the Modern patterns section).

       â†’ ìµœì¢…ì ìœ¼ë¡œ ë¹Œë”ê°€ ë³´ê²Œë  ì½”ë“œëŠ” ë§¤ìš° ì‹¬í”Œí•œ ì½”ë“œì…ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ ì‹¬í”Œí•œ ì½”ë“œëŠ” ìº¡ìŠí™”ë˜ì–´ì„œ ë‚´ë¶€êµ¬ì¡°ë¥¼ ì•Œ ìˆ˜ ì—†ê²Œ ì‘ì„±ë˜ì–´ìˆìŠµë‹ˆë‹¤.

       ì£¼ë¡œ dot(.)ì„ ì´ìš©í•´ì„œ ì²´ì´ë‹í•˜ë©´ì„œ build up í•˜ë©´ ìŒ“ì•„ê°„ë‹¤ìŒì— ìµœì¢… ì œí’ˆì„ ì¶œì‹œí•©ë‹ˆë‹¤.

       ## **Participants**

       The objects participating in this pattern are:

       - Director

         -- In example code:

         Shop

         - constructs products by using the Builder's multistep interface

       - Builder

         -- not used in JavaScript

         - declares a multistep interface for creating a complex product

       - ConcreteBuilder

         -- In example code:

         CarBuilder, TruckBuilder

         - implements the multistep Builder interface
         - maintains the product through the assembly process
         - offers the ability to retrieve the newly created product

       - Products

         -- In example code:

         Car, Truck

         - represents the complex objects being assembled

       â†’ í¬ê²Œ Director(ë¹Œë”ë¥¼ ì´ìš©í•´ì„œ ì ˆì°¨ë¥¼ ëª…ë ¹í•˜ëŠ” í•¨ìˆ˜), Builder(Directorê°€ ëª…ë ¹í•œ ì ˆì°¨ë¥¼ ìˆ˜í–‰í•˜ëŠ” í•¨ìˆ˜), Product(Builderê°€ ì ˆì°¨ë¥¼ ìˆ˜í–‰í•  ë•Œ í•„ìš”í•œ ë¶€í’ˆ) ìœ¼ë¡œ ë‚˜ë‰œë‹¤.

       ## Example

       The AbstractBuilder is not used because JavaScript does not support abstract classes. However, the different Builders must implement the same multistep interface for the Director to be able to step through the assembly process

       The JavaScript code has a `SammiRestraunt` (the Director) and two builder objects: `Cook`. The Shop's construct method accepts a Builder instance which it then takes through a series of assembly steps: `boil` , `season`, and `finishFood`. The Builder's get method returns the newly assembled products ( `Market` objects).

       The client has control over the actual object construction process by offering different builders to the `SammiRestraunt` .

       ## code

       ```jsx
       // product
       function Market() {
         this.getIngred = ingred => {
           this.ingred = ingred;
           return this.ingred;
         };
       }

       // Builder
       function Cook(ingred, food, num) {
         this.ingred = new Market().getIngred(ingred);

         this.boil = () => {
           this.ingred += 'ë¥¼ ì‚¶ì•„ì„œ';
           return this;
         };

         this.season = () => {
           this.ingred += ' ê°„ì„ í•´ì„œ';
           return this;
         };

         this.finishFood = () =>
           `${this.ingred} ì™„ì„±ëœ ìŒì‹, ${ingred}${food}ì´(ê°€) ${num}ì¸ë¶„ ë‚˜ì™”ìŠµë‹ˆë‹¤!ğŸ£`;
       }

       // Director
       function SammiRestraunt(ingred, food, num) {
         const completedFood = new Cook(ingred, food, num) //
           .boil()
           .season()
           .finishFood();
         return completedFood;
       }

       SammiRestraunt('ìƒˆìš°', 'ì´ˆë°¥', 2);
       // ì´ë ‡ê²Œ í•˜ë©´ 1ë‹¬ë’¤ì— ë´¤ì„ ë•Œ ë­ê°€ ë­˜ ëœ»í•˜ëŠ”ì§€ ëª¨ë¦„...

       // advanced Director ê°€ ë˜ì–´ì„œ SammiRestarauntì„ ë” ì§ê´€ì ìœ¼ë¡œ buildê°€ëŠ¥í•˜ë‹¤.
       // ì±Œë¦°ì§€!
       // ì•„ë˜ì™€ ê°™ì´ ë¹Œë“œí•´ ë³¼ ê²ƒ!
       /*
       new SammiRestraunt
            .ingredient('ìƒˆìš°')
            .food('ìƒˆìš°ì´ˆë°¥')
            .number(2)
            */
       //
       // 'ìƒˆìš°ë¡œ ë§Œë“  ìƒˆìš° ì´ˆë°¥ 2ì¸ë¶„' ì´ë¼ëŠ” ì£¼ë¬¸ì´ ë“¤ì–´ì™”ë‹¤ëŠ”ê±¸ ë°”ë¡œ ì•Œ ìˆ˜ ìˆë‹¤.

       // í•¨ìˆ˜í˜• í”„ë¡œê·¸ë˜ë°ìœ¼ë¡œ ì»´í¬ë„ŒíŠ¸ë¥¼ ë§Œë“¤ê³ ,
       // ê·¸ ì»´í¬ë„ŒíŠ¸ë“¤ì„ í™œìš©í•´ì„œ ë¹Œë“œí•œê±°ë¼ê³  ë³¼ ìˆ˜ ë„ ìˆì„ ê²ƒ ê°™ë‹¤.

       // Advanced Builder
       function SammiRestrauntBuild() {
         this.ingredient = ingred => {
           this.ingred = ingred;
           return this;
         };
         this.food = food => {
           this.food = food;
           return this;
         };

         this.number = num => {
           this.num = num;
           return SammiRestraunt(this.ingred, this.food, this.num);
         };
       }

       const shrimpSushi = new SammiRestrauntBuild()
         .ingredient('ìƒˆìš°')
         .food('ì´ˆë°¥')
         .number(2);

       // Another Advanced Buildler
       function SammiRestraunt(({ ingred, food, num } = {}) ) {
         const completedFood = new Cook(ingred, food, num) //
           .boil()
           .season()
           .finishFood();
         return completedFood;
       }

       SammiRestraunt({ ingred: 'ì—°ì–´', num: 2, food: 'ì´ˆë°¥' }); ì´ë ‡ê²Œë„ í•  ìˆ˜ ìˆë‹¤!!
       ```

   ### **êµ¬ì¡° íŒ¨í„´(Structural Patterns)**

   - í´ë˜ìŠ¤ë‚˜ ê°ì²´ë¥¼ ì¡°í•©í•´ ë” í° êµ¬ì¡°ë¥¼ ë§Œë“œëŠ” íŒ¨í„´ì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì„œë¡œ ë‹¤ë¥¸ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì§€ë‹Œ 2ê°œì˜ ê°ì²´ë¥¼ ë¬¶ì–´ ë‹¨ì¼ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ê±°ë‚˜ ì„œë¡œ ë‹¤ë¥¸ ê°ì²´ë“¤ì„ ë¬¶ì–´ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

   ### **í–‰ìœ„ íŒ¨í„´(Behavioral Patterns)**

   - ê°ì²´ë‚˜ í´ë˜ìŠ¤ ì‚¬ì´ì˜ ì•Œê³ ë¦¬ì¦˜ì´ë‚˜ ì±…ì„ ë¶„ë°°ì— ê´€ë ¨ëœ íŒ¨í„´ì…ë‹ˆë‹¤. í•œ ê°ì²´ê°€ í˜¼ì ìˆ˜í–‰í•  ìˆ˜ ì—†ëŠ” ì‘ì—…ì„ ì—¬ëŸ¬ê°œì˜ ê°ì²´ë¡œ ì–´ë–»ê²Œ ë¶„ë°°í•˜ëŠ”ì§€, ë˜ ê·¸ë ‡ê²Œ í•˜ë©´ì„œë„ ê°ì²´ ì‚¬ì´ì˜ ê²°í•©ë„ë¥¼ ìµœì†Œí™”í•˜ëŠ”ê²ƒì— ì¤‘ì ì„ ë‘ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

     - **ì˜µì €ë²„ íŒ¨í„´(oberserver pattern):** ê°ì²´ë“¤ ì‚¬ì´ì— 1 : N ì˜ ì˜ì¡´ê´€ê³„ë¥¼ ì •ì˜í•˜ì—¬ ì–´ë–¤ ê°ì²´ì˜ ìƒíƒœê°€ ë³€í•  ë•Œ, ì˜ì¡´ê´€ê³„ì— ìˆëŠ” ëª¨ë“  ê°ì²´ë“¤ì´ í†µì§€ë°›ê³  ìë™ìœ¼ë¡œ ê°±ì‹ ë  ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

       ## **JavaScript Observer**

       The **\*Observer\*** pattern offers a subscription model in which objects subscribe to an event and get notified when the event occurs. This pattern is the cornerstone of event driven programming, including JavaScript. The Observer pattern facilitates good object-oriented design and promotes loose coupling.

       ***

       ## **Using Observer**

       When building web apps you end up writing many event handlers. Event handlers are functions that will be notified when a certain event fires. These notifications optionally receive an event argument with details about the event (for example the x and y position of the mouse at a click event).

       The event and event-handler paradigm in JavaScript is the manifestation of the Observer design pattern. Another name for the Observer pattern is Pub/Sub, short for Publication/Subscription.

       ***

       ## **Diagram**

       ![https://www.dofactory.com/img/diagrams/javascript/javascript-observer.jpg](https://www.dofactory.com/img/diagrams/javascript/javascript-observer.jpg)

       ***

       ## **Participants**

       The objects participating in this pattern are:

       - Subject

         -- In example code:

         Click

         - maintains list of observers. Any number of Observer objects may observe a Subject
         - implements an interface that lets observer objects subscribe or unsubscribe
         - sends a notification to its observers when its state changes

       - Observers

         -- In example code:

         clickHandler

         - has a function signature that can be invoked when Subject changes (i.e. event occurs)

       ***

       ## **Example**

       The `Click` object represents the Subject. The `clickHandler` function is the subscribing Observer. This handler subscribes, unsubscribes, and then subscribes itself while events are firing. It gets notified only of events #1 and #3.

       Notice that the `fire` method accepts two arguments. The first one has details about the event and the second one is the context, that is, the `this` value for when the eventhandlers are called. If no context is provided `this` will be bound to the global object (window).

       ## code

       ```jsx
       function Click() {
         this.handlers = []; // observers
       }

       Click.prototype = {
         subscribe: function (fn) {
           this.handlers.push(fn);
         },

         unsubscribe: function (fn) {
           this.handlers = this.handlers.filter(function (item) {
             if (item !== fn) {
               return item;
             }
           });
         },

         fire: function (o, thisObj) {
           var scope = thisObj || window;
           this.handlers.forEach(function (item) {
             item.call(scope, o);
           });
         },
       };

       function run() {
         var clickHandler = function (item) {
           console.log('fired: ' + item);
         };

         var click = new Click();

         click.subscribe(clickHandler);
         click.fire('event #1');
         click.unsubscribe(clickHandler);
         click.fire('event #2');
         click.subscribe(clickHandler);
         click.fire('event #3');
       }
       ```

   _ë¹Œë”íŒ¨í„´ì„ ê³µë¶€í•˜ë©´ í•  ìˆ˜ë¡ ëŠê¼ˆë˜ê²ƒì€ , ìš°ë¦¬ê°€ ì´ë•Œê¹Œì§€ ë°°ìš´ê±°ë¥¼ ë‹¤ ì¨ë¨¹ëŠ” íŒ¨í„´ê°™ì•„ì„œ ì—°ì¥ì„ ìƒìœ¼ë¡œ ë°°ìš°ê¸°ì¢‹ì€ ì£¼ì œì¸ê±°ê°™ìŠµë‹ˆë‹¤. ì„ ì–¸ì ,í•¨ìˆ˜í˜•, ì»´í¬ë„ŒíŠ¸ ë‹¤ ì¨ì„œ ë¹Œë“œí•˜ê¸°ë•Œë¬¸ì´ì£ ._
