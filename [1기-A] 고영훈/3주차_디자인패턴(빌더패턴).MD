2. - ## **소프트웨어 디자인 패턴이란?**

   소프트웨어 개발 방법으로 사용되는 디자인패턴(Desigin Pattern)은 과거의 소프트웨어 개발 과정에서 발견된 설계의 노하우를 축적하여 그 방법에 이름을 붙여서 **이후에 재사용하기 좋은 형태로 특정 규약을 만들어서 정리한 것입니다.** 디자인 패턴은 소프트웨어 설계에 있어 공통적인 문제들에 대한 표준적인 해법과 작명법을 제안하며, 알고리즘과 같이 프로그램 코드로 바로 변환될 수 있는 형태는 아니지만, **특정한 상황에서 구조적인 문제를 해결하는 방식입니다. 즉 "효율적인 코드를 만들기 위한 방법론"이라고 생각하시면 됩니다.**

   - 또는 특정 문제를 해결하기 위한 '틀' , '템플릿' 이라고 생각해도 됩니다.

     > _A pattern is a reusable solution that can be applied to **commonly occurring problems** in software design - in our case - in writing JavaScript web applications. Another way of looking at patterns are as **templates for how we solve problems** - ones which can be used in quite a few different situations_.

     \*-"**Javascript design pattern**" written by "**Addy Osmani"\***

   로토님의 컴포넌트 코딩도 디자인 패턴이 될 수 있습니다. 그리고 컴포넌트의 구성요소도 디자인 패턴이 될 수 있습니다. 흔히 일어나는 문제를 해결하기 위해 마련된 설계도라고 보면됩니다.

   단, 디자인 패턴은 외우기보다는 어떠한 패턴이 있는지 알고 수많은 디자인 패턴에서 다양한 코딩 노하우를 습득하는것이 중요하다고 생각합니다. "이 코드에는 무조건 이 패턴을 적용시킬거야!" 이것이 아니라 여러가지 패턴이 자연스럽게 내 코드에 녹아드는것이 좋다고 생각합니다.

   ## **디자인 패턴의 종류**

   - **크게 세가지 패턴으로 나뉠 수 있습니다. 패턴안에 또 하위 패턴이 무수히 존재하는데, 그 중에 빌더랑 옵저버 패턴만 깊게 알아 보려고 합니다.**

   ### **생성 패턴(Creational Patterns)**

   - 객체 생성에 관련된 패턴입니다. 객체의 생성과 조합을

     캡슐화

     해

     특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공합니다.

     - **빌더 패턴(Builder) :** 복합 객체의 생성과정과 표현과정을 분리시켜 동일한 생성과정에서 다양한 표현을 생성할 수 있는 패턴입니다.

       ## Using Builder

       The most common motivation for using Builder is to simplify client code that creates complex objects. The client can still direct the steps taken by the Builder without knowing how the actual work is accomplished. Builders frequently encapsulate construction of Composite objects (another GoF design pattern) because the procedures involved are often repetitive and complex.

       Usually it is the last step that returns the newly created object which makes it easy for a Builder to participate in fluent interfaces in which multiple method calls, separated by dot operators, are chained together (note: fluent interfaces are implementation of the Chaining Pattern as presented in the Modern patterns section).

       → 최종적으로 빌더가 보게될 코드는 매우 심플한 코드입니다. 그러나 그 심플한 코드는 캡슐화되어서 내부구조를 알 수 없게 작성되어있습니다.

       주로 dot(.)을 이용해서 체이닝하면서 build up 하면 쌓아간다음에 최종 제품을 출시합니다.

       ## **Participants**

       The objects participating in this pattern are:

       - Director

         -- In example code:

         Shop

         - constructs products by using the Builder's multistep interface

       - Builder

         -- not used in JavaScript

         - declares a multistep interface for creating a complex product

       - ConcreteBuilder

         -- In example code:

         CarBuilder, TruckBuilder

         - implements the multistep Builder interface
         - maintains the product through the assembly process
         - offers the ability to retrieve the newly created product

       - Products

         -- In example code:

         Car, Truck

         - represents the complex objects being assembled

       → 크게 Director(빌더를 이용해서 절차를 명령하는 함수), Builder(Director가 명령한 절차를 수행하는 함수), Product(Builder가 절차를 수행할 때 필요한 부품) 으로 나뉜다.

       ## Example

       The AbstractBuilder is not used because JavaScript does not support abstract classes. However, the different Builders must implement the same multistep interface for the Director to be able to step through the assembly process

       The JavaScript code has a `SammiRestraunt` (the Director) and two builder objects: `Cook`. The Shop's construct method accepts a Builder instance which it then takes through a series of assembly steps: `boil` , `season`, and `finishFood`. The Builder's get method returns the newly assembled products ( `Market` objects).

       The client has control over the actual object construction process by offering different builders to the `SammiRestraunt` .

       ## code

       ```jsx
       // product
       function Market() {
         this.getIngred = ingred => {
           this.ingred = ingred;
           return this.ingred;
         };
       }

       // Builder
       function Cook(ingred, food, num) {
         this.ingred = new Market().getIngred(ingred);

         this.boil = () => {
           this.ingred += '를 삶아서';
           return this;
         };

         this.season = () => {
           this.ingred += ' 간을 해서';
           return this;
         };

         this.finishFood = () =>
           `${this.ingred} 완성된 음식, ${ingred}${food}이(가) ${num}인분 나왔습니다!🍣`;
       }

       // Director
       function SammiRestraunt(ingred, food, num) {
         const completedFood = new Cook(ingred, food, num) //
           .boil()
           .season()
           .finishFood();
         return completedFood;
       }

       SammiRestraunt('새우', '초밥', 2);
       // 이렇게 하면 1달뒤에 봤을 때 뭐가 뭘 뜻하는지 모름...

       // advanced Director 가 되어서 SammiRestaraunt을 더 직관적으로 build가능하다.
       // 챌린지!
       // 아래와 같이 빌드해 볼 것!
       /*
       new SammiRestraunt
            .ingredient('새우')
            .food('새우초밥')
            .number(2)
            */
       //
       // '새우로 만든 새우 초밥 2인분' 이라는 주문이 들어왔다는걸 바로 알 수 있다.

       // 함수형 프로그래밍으로 컴포넌트를 만들고,
       // 그 컴포넌트들을 활용해서 빌드한거라고 볼 수 도 있을 것 같다.

       // Advanced Builder
       function SammiRestrauntBuild() {
         this.ingredient = ingred => {
           this.ingred = ingred;
           return this;
         };
         this.food = food => {
           this.food = food;
           return this;
         };

         this.number = num => {
           this.num = num;
           return SammiRestraunt(this.ingred, this.food, this.num);
         };
       }

       const shrimpSushi = new SammiRestrauntBuild()
         .ingredient('새우')
         .food('초밥')
         .number(2);

       // Another Advanced Buildler
       function SammiRestraunt(({ ingred, food, num } = {}) ) {
         const completedFood = new Cook(ingred, food, num) //
           .boil()
           .season()
           .finishFood();
         return completedFood;
       }

       SammiRestraunt({ ingred: '연어', num: 2, food: '초밥' }); 이렇게도 할 수 있다!!
       ```

   ### **구조 패턴(Structural Patterns)**

   - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴입니다. 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 서로 다른 객체들을 묶어 새로운 기능을 제공하는 패턴입니다.

   ### **행위 패턴(Behavioral Patterns)**

   - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴입니다. 한 객체가 혼자 수행할 수 없는 작업을 여러개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는것에 중점을 두는 방식입니다.

     - **옵저버 패턴(oberserver pattern):** 객체들 사이에 1 : N 의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴입니다.

       ## **JavaScript Observer**

       The **\*Observer\*** pattern offers a subscription model in which objects subscribe to an event and get notified when the event occurs. This pattern is the cornerstone of event driven programming, including JavaScript. The Observer pattern facilitates good object-oriented design and promotes loose coupling.

       ***

       ## **Using Observer**

       When building web apps you end up writing many event handlers. Event handlers are functions that will be notified when a certain event fires. These notifications optionally receive an event argument with details about the event (for example the x and y position of the mouse at a click event).

       The event and event-handler paradigm in JavaScript is the manifestation of the Observer design pattern. Another name for the Observer pattern is Pub/Sub, short for Publication/Subscription.

       ***

       ## **Diagram**

       ![https://www.dofactory.com/img/diagrams/javascript/javascript-observer.jpg](https://www.dofactory.com/img/diagrams/javascript/javascript-observer.jpg)

       ***

       ## **Participants**

       The objects participating in this pattern are:

       - Subject

         -- In example code:

         Click

         - maintains list of observers. Any number of Observer objects may observe a Subject
         - implements an interface that lets observer objects subscribe or unsubscribe
         - sends a notification to its observers when its state changes

       - Observers

         -- In example code:

         clickHandler

         - has a function signature that can be invoked when Subject changes (i.e. event occurs)

       ***

       ## **Example**

       The `Click` object represents the Subject. The `clickHandler` function is the subscribing Observer. This handler subscribes, unsubscribes, and then subscribes itself while events are firing. It gets notified only of events #1 and #3.

       Notice that the `fire` method accepts two arguments. The first one has details about the event and the second one is the context, that is, the `this` value for when the eventhandlers are called. If no context is provided `this` will be bound to the global object (window).

       ## code

       ```jsx
       function Click() {
         this.handlers = []; // observers
       }

       Click.prototype = {
         subscribe: function (fn) {
           this.handlers.push(fn);
         },

         unsubscribe: function (fn) {
           this.handlers = this.handlers.filter(function (item) {
             if (item !== fn) {
               return item;
             }
           });
         },

         fire: function (o, thisObj) {
           var scope = thisObj || window;
           this.handlers.forEach(function (item) {
             item.call(scope, o);
           });
         },
       };

       function run() {
         var clickHandler = function (item) {
           console.log('fired: ' + item);
         };

         var click = new Click();

         click.subscribe(clickHandler);
         click.fire('event #1');
         click.unsubscribe(clickHandler);
         click.fire('event #2');
         click.subscribe(clickHandler);
         click.fire('event #3');
       }
       ```

   _빌더패턴을 공부하면 할 수록 느꼈던것은 , 우리가 이때까지 배운거를 다 써먹는 패턴같아서 연장선상으로 배우기좋은 주제인거같습니다. 선언적,함수형, 컴포넌트 다 써서 빌드하기때문이죠._
