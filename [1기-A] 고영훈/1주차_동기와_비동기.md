# 실생활에서의 동기와 비동기

- 동기(synchronous): 요청을 보낸후, 해당 요청의 응답을 '받아야 다음 작업이 비로소 실행'이 됨
- 비동기(asynchronous): 요청을 보낸후, 해당 요청의 응답과 '상관없이 다음 작업이 실행'이 됨.

- 동기적으로 흘러가야하는 상황

  신호등, 발표, 선풍기

- 비동기적으로 흘러가야하는 상황

  식당에서 여럿이 주문하고 밥나올 때, 우리 몸

- 그럼 요리는?

  동기+비동기

# 그럼 자바스크립트는?

- 자바스크립트라는 언어는 그럼 동기? 아님 비동기?

  동기적 언어. 싱글 쓰레드이기 때문.

  - 즉 , 작업공간이 하나밖에 없기 때문에 한번에 하나씩밖에 처리를 못한다. 다른 일꾼에게 양도할 수 가 없다.(기본적으로는) 코드를 통해 살펴보자

  ```javascript
  function one() {
    two();
    console.log(1);
  }
  function two() {
    three();
    console.log(2);
  }

  function three() {
    console.log(3);
  }

  one();
  ```

  이 코드를 [lopue](http://latentflip.com/loupe/?code=JC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKY29uc29sZS5sb2coIkhpISIpOwoKc2V0VGltZW91dChmdW5jdGlvbiB0aW1lb3V0KCkgewogICAgY29uc29sZS5sb2coIkNsaWNrIHRoZSBidXR0b24hIik7Cn0sIDUwMDApOwoKY29uc29sZS5sb2coIldlbGNvbWUgdG8gbG91cGUuIik7!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D)라는 사이트에서 돌려보자. loupe는 콜스택에 함수들이 쌓이는 것을 시각화해주는 사이트이다.

  ![callstack](https://github.com/prgrms-web-devcourse/FE-August-study/blob/11da9556fa79f5e1b45a5856770ed1d038acdcba/%5B1%EA%B8%B0-A%5D%20%EA%B3%A0%EC%98%81%ED%9B%88_1%EC%A3%BC%EC%B0%A8%20%EC%8A%A4%ED%84%B0%EB%94%94/img/callstack.png){:class="img-fluid"}

  요런식으로 말이다. `one() -> two() -> three()` 요 순서대로 쌓여서 실행이 된다.

  **_근데 비동기로 처리가 가능한 이유는?_**

  <WEB api와 이벤트루프때문이다.>

![event-loop](https://github.com/prgrms-web-devcourse/FE-August-study/blob/11da9556fa79f5e1b45a5856770ed1d038acdcba/%5B1%EA%B8%B0-A%5D%20%EA%B3%A0%EC%98%81%ED%9B%88_1%EC%A3%BC%EC%B0%A8%20%EC%8A%A4%ED%84%B0%EB%94%94/img/event-loop.png){:class="img-fluid"}

자바스크립트 엔진에서 좀 시간이 오래걸리는 작업(setTimeOut, Promise와 같은 함수)은 webApi로 넘겨준다. 그럼 EventLoop는 그 작업들을 콜백큐에 쌓아놓은 다음에(promise는 microtask에 쌓인다) 콜스택이 비워지고 나면 콜스택으로 넘겨준다.

그래서 EventLoop를 한마디로 마블 영웅 중에 '플래시' 라고 생각하면 이해하기가 조금 쉬울거다. 끊임없이 브라우저와 자바스크립트사이를 왔다갔다하면서 콜스택이 비워지면 태스크 큐나 마이크로 태스크 큐에 있는 것들을 콜스택으로 넘겨주고 16.6ms마다 브라우저 페이지를 랜더링하기도 한다(DOM Tree -> layout -> paint)

# 비동기를 쓰는 이유

**_마냥 언제까지 기다릴수는 없잖어....😩😩._**

그렇다... 시간이 오래걸리는 작업을 기다리다가 다음작업을 실행하게 되면 그 다음작업들은 그냥 실행되지 못하고 가만히 있게 된다. 그럼 비효율적이다. 오래걸리는것은 브라우저로 넘겨준다. 그리고 빨리 걸리는것들을 자바스크립트가 다 처리하고 나면 그제서야 오래걸리는 것들을 태스크 큐에서 받아와서 처리하게 된다.

![setTimeOut](https://github.com/prgrms-web-devcourse/FE-August-study/blob/11da9556fa79f5e1b45a5856770ed1d038acdcba/%5B1%EA%B8%B0-A%5D%20%EA%B3%A0%EC%98%81%ED%9B%88_1%EC%A3%BC%EC%B0%A8%20%EC%8A%A4%ED%84%B0%EB%94%94/img/setTimeOut.png){:class="img-fluid"}

- 그림으로 비동기적 과정을 실습해보자!

```javascript

console.log('Hi!');

setTimeout(function timeout() {
  console.log('5 seconds after');
}, 5000);

setTimeout(function timeout2() {
  console.log('6 seconds after');
}, 6000);

setTimeout(function timeout3() {
  console.log('7 seconds after');
}, 7000);

console.log('Good bye!');

Hi! 
Good bye! 
5 seconds after 
6 seconds after
7 seconds after

```

setTimeOut은 브라우저로 넘겨주면 콘솔로그만 콜스택에 남게된다. 그럼 콘솔로그가 다실행되고 난뒤에 이벤트 루프는 콜스택이 비워진것을 확인하고 setTimeOut함수 안에 있는 콜백함수를 자바스크립트 콜스택으로 넘겨주게 된다.

그럼 실제로 fetch를 이용해서 데이터를 받아오도록 하자.

```jsx
async function getRandomUser() {
  const res = await fetch('<https://randomuser.me/api>');
  const data = await res.json();

  const user = data['results'][0];

  const newUser = {
    name: `${user.name.first} ${user.name.last}`,
    money: Math.floor(Math.random() * 1000000),
  };

  console.log('데이터 불러오기 완료!', newUser);
}

//비동기 작업 실행

console.log('안녕!');

getRandomUser();

console.log('잘가!');

// 안녕!
// 잘가!
// 데이터 불러오기 완료!
// {name: "Marie Girard", money: 333527}
```

`https://randomuser.me/api` 는 랜덤으로 사람의 정보를 받아오는 api이다. 여기서 데이터를 받아오도록 해보자.

그럼 로그가 일단 출력되고 시간이 오래걸리는 fetch는 나중에 실행되는것을 알 수 있다. 위의 비동기적인 절차를 거치기 때문이다(_참고로 async 함수가 promise를 리턴하는것이 아니라 fetch가 promise를 리턴한다!!_)

그럼 이제 콜스택에 있는 함수가 비워지지 않으면 브라우저가 어떻게 작동되는지 재밌는(?) 실험을 해보자 후후

```html
<body>
  <button class="while">While True</button>
</body>
```

```javascript
const whileButton = document.querySelector('.while');
const asyncButton = document.querySelector('.async');
const div = document.querySelector('.result');

let num = 0;

function buttonStop() {
  while (true) {}
}

function asyncNumUpdate() {
  setInterval(() => {
    // console.log(num++);
    num++;
    div.innerHTML = num;
  }, 1000);
}

whileButton.addEventListener('click', buttonStop);
asyncButton.addEventListener('click', asyncNumUpdate);
```

WHILE 버튼을 만들고 그 버튼에 `WHILE(TRUE){}` 를 추가해주었다. 그리고 WHILE 버튼을 누르면??

![while](https://github.com/prgrms-web-devcourse/FE-August-study/blob/11da9556fa79f5e1b45a5856770ed1d038acdcba/%5B1%EA%B8%B0-A%5D%20%EA%B3%A0%EC%98%81%ED%9B%88_1%EC%A3%BC%EC%B0%A8%20%EC%8A%A4%ED%84%B0%EB%94%94/img/while.gif){:class="img-fluid"}

요런식으로 브라우저가 죽어버린다...ㅠㅠ(지켜주지 못해 미안해😥)

콜스택이 비워지지 않으면 이벤트 루프는 콜스택에 멈춰버리게 되고 그럼 브라우저 랜더링을 못하게 되므로 브라우저기능이 말그대로 마비된다.

그럼 setInterval로 이번에 실험을 해보자. setInterval 함수는 지속적으로 콜백을 실행시키는 함수인데 이 함수가 지속적으로 콜스택에 무언가를 쌓아두면 브라우저는 어떻게 될까?

```html
<body>
  <button class="async">Async Num Update</button>
  <div class="result"></div>
</body>
```

```javascript
const asyncButton = document.querySelector('.async');
const div = document.querySelector('.result');

let num = 0;

function asyncNumUpdate() {
  setInterval(() => {
    // console.log(num++);
    num++;
    div.innerHTML = num;
  }, 1000);
}

asyncButton.addEventListener('click', asyncNumUpdate);
```

async버튼을 누르면 번호가 1초마다 갱신되면서 div에 표시되는 함수를 넘겨준다. 자 누르면은???

![setInterval](https://github.com/prgrms-web-devcourse/FE-August-study/blob/11da9556fa79f5e1b45a5856770ed1d038acdcba/%5B1%EA%B8%B0-A%5D%20%EA%B3%A0%EC%98%81%ED%9B%88_1%EC%A3%BC%EC%B0%A8%20%EC%8A%A4%ED%84%B0%EB%94%94/img/setInterval.gif){:class="img-fluid"}

다행히도 브라우저는 여전히 작동한다! 콜스택에 쌓이지 않기 때문이다. 이벤트 루프가 setInterval안에 있는 콜백을 브라우저 태스크 큐와 콜스택에 계속 넘겨준다. 그만큼 빠르시다는 거다 후후

# 느낀점

_이로써 브라우저와 자바스크립트와의 환상적인 호흡을 살펴보았다. 공부하면서 느낀것은, 내가 너무나 당연하게 일상에서 수천번 접하던 웹사이트 뒤에서 이런 마법같은 일이 일어나고 있는지 몰랐다._

_너무나 신기했고 그 원리를 이해한것 같아서 큰 그림이 조금씩 보이는것 같아 뿌듯하기도 했다. 동작원리를 이해하면 예외상황이 발생했을때 좀더 잘 처리할 수 있을것 같은 느낌이 들기도 했다!_
