✔ _Javascript 기준의_ 가비지 컬렉션에 대한 공부



# ❓ 가비지 컬렉션(Garbage Collection, GC)

- 메모리 관리 기법 중 하나
- 자동 메모리 관리 방법
- 더 이상 사용하지 않는 메모리를 자동으로 해제하는 것

---



# ❓ 메모리 생명 주기

1. (변수 선언) -> 필요한 메모리 **할당**

   ​                ⬇

2. 할당된 메모리 **사용** (읽기, 쓰기)

   ​                ⬇

3. 해당 메모리가 필요 없어지면 **해제**

- (프로그래밍 언어에 상관 X) 일반적인 생명 주기
- 저급 프로그래밍 언어(C 등)에서는 1,3의 과정을 프로그래머가 **직접** 해줌 (해제해주는 함수인 malloc(), free())과 같은 함수 존재, 하지만 자바스크립트에는 이런 함수 없음)
- But, 고급 프로그래밍 언어(Java, Javascript 등)에서는 프로그래머가 하지 않아도 **자동으로** 할당과 해제가 이루어짐.
- 변수가 선언되면 자동으로 메모리 공간을 할당함.
- 자바스크립트에서는 엔진에 내장된 가비지 컬렉터가 자동으로 수행되어 객체들을 모니터링하며, 도달할 수 없는 객체는 삭제함
- 자바스크립트는 더 이상 사용되지 않을 변수와 함수를 Heap(메모리 힙)에서 제거함으로써 메모리를 효율적으로 관리함. 이러한 역할을 수행해주는 도구를 Garbage Collector라고 함.



### 🛑용어 정리

- 가비지 컬렉션 = 자동 메모리 관리 **알고리즘**(방법)
- 가비지 컬렉터 = 시스템에서 가비지 컬렉션 작업을 **수행**하는 **객체**
- 가비지 = 유효하지 않은 메모리 주소 중 **아직 해제되지 않은 메모리**(= 해제되지 않은 메모리 영역) (= 정리되지 않은 메모리) (= 사용하지 않는 메모리)

---



# ❓ 목적

- 메모리 할당을 추적하고 할당된 메모리 블록이 더이상 필요하지 않은지를 판단하여 해제



# ❓ 필요하지 않은지 어떻게 판별할까

- *레퍼런스 카운팅 알고리즘(Reference Counting Algorithms)*과 *표시하고 쓸기 알고리즘(Mark and Sweep Algorithms)*가 있다.


> <span style="font-size:1.2em">레퍼런스 카운팅 알고리즘(Reference Counting Algorithms)</span>

- ❗❗참조❗❗

- <span style="color:#AD9AEE">더 이상 필요없는 객체를 **어떤 다른 객체도 "참조"하지 않는 객체**로 정의함</span>

- 어떤 값에 대해 어디에서도 참조되지 않고 있으면 이 값을 가비지로 간주하고 해제함

- 각 객체가 얼마나 많이 참조되는지를 카운트함

- ❌한계점 : 순환참조인 경우 가비지로 인식하지 못함

    function f() {
    let x = {};
    let y = {};
    x.a = y;   //x는 y를 참조한다
    y.a = x;   //y는 x를 참조한다
    }
  
    f();

  => f()함수가 호출 후에 실행이 끝나면 내부 요소는 더 이상 사용하지 않는 메모리이기 때문에 메모리가 해제되어야 함. 근데 서로 참조하고 있기 때문에 가비지로 인식하지 못함 => 메모리가 해제되지 않고 계속 남아있음 => f()함수가 호출될 때마다 x,y 객체만큼의 메모리가 계속 할당되어 메모리가 낭비됨.

  
> <span style="font-size:1.2em">표시하고 쓸기 알고리즘(Mark and Sweep Algorithms)</span>

- 레퍼런스 카운팅 알고리즘의 한계를 극복한 알고리즘 => 가장 많이 쓰이는 알고리즘

- <span style="color:#AD9AEE">더 이상 필요없는 오브젝트를 **닿을 수 없는 오브젝트**로 정의</span>

- 어떤 객체가 가비지가 아닌지 표시(mark)하고, 그 다음 마크가 되지 않은 가비지들은 메모리를 해제함(sweep)

- 최상위 객체인 루트(window객체 또는 global객체)에서 시작해서 닿을 수 없는 객체는 가비지로 인식

![image](https://user-images.githubusercontent.com/55550034/129959179-5b1f60ab-c0e2-40fe-a653-4203bb1760f1.png)

- 어떤 객체와 연결되어 있더라도 루트(window객체 혹은 global객체)에서 떨어져 있는 객체들은 가비지로 인식 -> 레퍼런스 카운트 알고리즘의 한계점인 순환참조일 때 해제되지 않는 문제 해결

- ❌한계점

  - 수동으로 메모리를 해제할 수 없음(접근할 수 있는 함수가 없음)
  - 개발자가 가비지 컬렉션이 정확히 언제 작동할지 알기가 어려움 => 즉, 때에 따라 프로그램이 실제로 필요한 것 보다 더 많은 메모리를 사용할 수도 있다.

---

> references

[https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d](https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d)
[https://canoe726.tistory.com/37](https://canoe726.tistory.com/37)
[https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management](https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Managementhttps://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management)