## 브라우저 렌더링 과정 📝

![002](https://user-images.githubusercontent.com/69751205/128706015-fcdbc24d-c5fd-4ea5-ad51-16bdd3c54fd2.png)
렌더링이란 브라우저의 렌더링 엔진이 리소스를 서버로부터 가져와 화면에 페인팅하는 과정입니다.

![003](https://user-images.githubusercontent.com/69751205/128706051-b0fed6d5-6c2f-45d1-b61e-593330e28d77.png)
브라우저는 이렇게 4가지의 과정을 통해 화면에 렌더링을 하게 됩니다.

![004](https://user-images.githubusercontent.com/69751205/128706088-6ad477ad-757c-436e-962b-d209bbca53ca.png)
첫번째는 서버로부터 리소스를 받아오기입니다. 브라우저에 우리가 보고자하는 화면을 서버로부터 받아오는 과정입니다. 이는 주소창에 URL를 입력함으로써 서버에 요청하고 응답받을 수 있습니다. 이때 URL의 호스트네임, 즉 도메인이라는 파랑색 글이 DNS 프로토콜을 통해 IP주소로 변환되고 IP주소에 해당되는 서버로부터 요청된 페이지를 응답합니다.
(뒤에 위치나, query가 없는 경우 루트폴더의 index.html를 반환합니다.)

![005](https://user-images.githubusercontent.com/69751205/128706128-4a375101-000b-4c58-b89f-fa2d6dcf1cfe.png)
방금 서버에 요청해서 받아온 html 파일이라고 가정합니다. 두번째로 html와 css를 파싱해서 DOM과 CSSOM 생성하고  이를 통해 렌더트리를 만듭니다. 여기서 파싱이란 텍스트 문서의 문자열을 가장 기본적인 요소로 분해해 의미와 구조에 맞게 파스트리를 생성하는 과정을 말합니다.

![006](https://user-images.githubusercontent.com/69751205/128706166-5f858fc3-02f2-4c2f-9f1f-bba40c76ae2e.png)
위 그림은 html를 DOM으로 만든 겁니다. 사실 서버로부터 html를 받을 때, 바이트 코드로 받게 되고 이를 렌더링 엔진이 문자열로 바꾸고, 바꾼 문자열을 파싱해서 DOM트리를 만들어냅니다.

![007](https://user-images.githubusercontent.com/69751205/128706190-f4f44cd4-fd8c-44ac-b83c-b72870558f5b.png)
브라우저가 열심히 파싱하는 도중 링크 태그나 스타일 태그를 만나면, DOM 생성을 중단하고 서버에게 속성에 있는 css 파일을 요청하고 응답 받습니다.

![008](https://user-images.githubusercontent.com/69751205/128706236-d39c8a92-7b18-4e05-9e9f-2b584a37c8d7.png)
응답받은 css는 html과 마찬가지의 과정을 통해 CSSOM를 만들어냅니다. 이때 CSSOM는 CSS의 상속을 반영합니다. (html과 마찬가지로 바이트코드 -> 문자열 -> 파싱의 과정을 거침)

![009](https://user-images.githubusercontent.com/69751205/128706261-739c186a-734a-4c05-a276-d2e65d0724dc.png)
CSSOM가 다 만들어지면 html는 다시 파싱을 이어하고 DOM을 완성시킵니다. 완성된 DOM과 CSSOM를 결합해 렌더 트리를 생성합니다.

![010](https://user-images.githubusercontent.com/69751205/128706275-8ae03fef-dbd8-459e-8ec6-8f509250b45f.png)
하지만 우리는 html, css만 사용하는 것이 아닌 자바스크립트도 사용합니다. 그림에서처럼 스크립트 태그를 만나게 됩니다. 그럼 css와 마찬가지로 html을 파싱하는 것을 중단하고 렌더링 엔진이 아닌 자바스크립트 엔진에게 주도권이 넘어가게됩니다. 자바스크립트 엔진은 파일을 서버에 요청해 응답받고, 코드를 로드하고 파싱하고 실행을 하게 됩니다.

![011](https://user-images.githubusercontent.com/69751205/128706315-a0a33e94-3eef-4e4d-aad6-c034a22e7281.png)
자바스크립트 엔진은 코드를 토크나이징하고 파싱해 AST를 만들어냅니다. 그리고 AST를 바이트코드로 변환해 인터프리터가 해석해 실행하게 합니다.

![012](https://user-images.githubusercontent.com/69751205/128706337-b89dc233-f615-4898-8f12-5864c0c21f9f.png)
위 그림은 간단한 변수 선언할당문 코드를 AST로 바꾼것을 나타냅니다. hi 변수는 아이덴티파이 즉 사용자 지정 식별자, 문자열 헬로우는 스트링리터럴로 구문분석과 어휘 분석이 되어 트리를 구성하고 있습니다.

![013](https://user-images.githubusercontent.com/69751205/128706366-931fbefa-1d72-4c22-bf4c-19d923a0c35a.png)
자바스크립트 코드의 실행까지 끝나게 되면 노드 추가나 삭제 등의 DOM과 CSSOM에 변경이 있을 수있습니다. 이 변경은 DOM API가 가능하게 하는 것이고 변경된 내용을 토대로 새로운 렌더 트리를 만들어줍니다. 렌더 트리가 다 생성된다면 페인팅을 통해 화면에 보여지게 됩니다.

![014](https://user-images.githubusercontent.com/69751205/128706417-b3abf6e8-8a57-4472-af8e-e1ba3ffc64ab.png)
여기서 용어 두가지가 나옵니다. 리플로우와 리페인팅입니다. 리플로우는 노드 추가 삭제,  엘리먼트 크기 위치 변경 등 레이아웃이 계산을 다시하는 것이고, 리페인팅은 새 렌더트리로 다시 페인팅하는 것입니다. 이는 다시 렌더트리를 만들고 페인팅을 해야하기 때문에 발생하지 않게 하는 것이 중요합니다.

![015](https://user-images.githubusercontent.com/69751205/128706453-c8f94ccf-e42c-4068-9242-9f2ff86ea593.png)
렌더링 방식의 단점은 DOM생성이 자주 중단되어 오버헤드가 발생하고 DOM 생성시점에 따라 이런 타입에러를 낼 수 있다는점입니다.

![016](https://user-images.githubusercontent.com/69751205/128706479-e63ac313-d784-41f3-b59e-37d3c61fcbe0.png)
이에 대한 해결방안은 우선 스크립트 태그를 body 맨 뒤에 위치하게 함으로써 DOM이 다 생성된 후 실행하게끔 하는 방법이 있습니다. 또는 스크립트 태그에 async, defer를 사용할 수 있습니다. 
async 경우, 스크립트 태그를 만났을때, 비동기적으로 자바스크립트 엔진이 파일을 로드합니다. 이를 통해 dom 생성과 자바스크립트 파일 로드를 동시에 할 수 있습니다. 하지만, 로드가 끝나면 결국 dom 생성은 중단되고 자바스크립트 파일이 파싱되고 실행됩니다.
defer를 dom 생성과 자바스크립트 파일의 로드를 동시에 할수있습니다. 하지만 defer를 로드가 끝난 뒤, dom 생성을 중단시키지않고 dom 생성이 끝날때 까지 기다렸다가 이벤트를 받아 자바스크립트 파일을 파싱하고 실행하게 됩니다.

## 블로그 📝
<hr>

공부하면서 좀 더 자세히 적어놓은 포스팅입니다! [여기💬](https://velog.io/@songsong/JavaScriptDeepDive-38.-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95)