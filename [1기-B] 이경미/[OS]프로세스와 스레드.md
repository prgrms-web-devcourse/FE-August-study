시작은 이벤트 루프 강의에서 나온 "자바스크립트 엔진은 싱글 스레드로 이루어져 있는데 어떻게 한번에 여러 요청을 처리할 수있을까?"라는 말 때문이었다. 스레드가 뭘까? 라는 생각에 검색을 시작했고, 이것을 기회삼아 더 자세히 알고 싶어졌다. 


# 프로세스란?

> 프로세스란 CPU에 의해 연속적으로 처리 및 실행 되고 있는 **컴퓨터 프로그램**

엇? 그럼 프로그램과 프로세스는 같은 단어인걸까? 이게 무슨말이지? 싶었다. 프로세스를 이해하기 위해서는 프로그램이 정확히 무엇을 의미 하는지 알아야 한다. 그래서 프로그램의 정의를 보면
> 컴퓨터를 실행시키기 위해 차례대로 작성된 **명령어모음**

다시 풀이해 보자면 프로그램은 어떤 문제를 해결하기 위해 컴퓨터에 자료 처리 방법과 순서를 기술한 일련의 명령문의 집합체로 프로그래머가 작성해 컴파일한 코드덩어리이다. 정리하면 **프로그램은 디스크에 저장된 파일**이고 이파일을 더블 클릭해서 **실행 하면 프로세스**가 되는 것이다. 

## 멀티태스킹

window 작업관리자를 열어서 확인해 지금 실행중인 프로세스들을 확인할 수 있다. 이렇게 많은 프로세스들이 어떻게 동시에 실행 되고 있는걸까? 이를 위해 멀티태스킹에 대해 설명하겠다.
![작업관리자](https://images.velog.io/images/goum/post/b6794e4a-1afd-4278-ae0d-ecf272df1474/Untitled.png)
>멀티태스킹이란 OS를 통해 CPU가 작업하는데 필요한 자원(시간)을 프로세스 또는 스레드간에 나누는 행위를 말한다. 

이를 통해 여러 응용 프로그램을 동시에 열고 작업 할 수 있다는 장점이 있다.
음악을 들으면서, 웹서핑을 하고, 메신저의 메시지를 확인할 수 있는 이유는 모두 멀티태스킹 덕분이다.
![프로세스](https://miro.medium.com/max/700/0*jvlxE7iwWWLvzxgo.png)
이런 프로세스들은 동시에 실행되고 관리되는거 같이 보이지만, 사실 CPU는 한번에 한 프로세스만 실행 할 수 있다. 동시가아닌 재빠르게 프로세스들을 번갈아가며 실행하고, 관리하는 것이 동시에 하는 것처럼 보이는 것이다. 그리고 이렇게 프로세스를 전환 할 때 Context Switching이 일어난다.
> Context Switching이란 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말한다.

## 프로세스 상태 전이
프로그램이 실행되어 프로세스가 되고 종료되어 다시 프로그램이 되기 까지 프로세스는 어떤 일을 겪을까?
앞서 말한거 처럼 CPU는 여러 프로세스를 빠르게 전환 하여 실행하기 때문에 여러 상태에 놓인다. 프로세스의 상태와 각 상태에서 다른 상태로 전이 되는게 어떤의미를 가지는지 알아보자. ![프로세스의 상태 변화도](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/240934e5-c087-4f04-bd9d-6e310827152d/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAT73L2G45O3KS52Y5%2F20210808%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20210808T014045Z&X-Amz-Expires=86400&X-Amz-Signature=9e1964e7b748e12b64005fb715c4b16b7a7feca75077c9369fd322f0ab8266ee&X-Amz-SignedHeaders=host&response-content-disposition=filename%20%3D%22Untitled.png%22)

### 프로세스의 상태
- **new** : 프로세스 생성중, 프로세스를 생성하고 있는 단계로 커널공간에 PCB가 만들어진 상태
- **ready** : 프로세스가 CPU를 기다리는 상태, 프로세스가 메모리에 적재된 상태로 실행하는데 필요한 자원을 모두 얻은 상태 아직 CPU를 받지는 않았지만 CPU를 할당받으면 바로 실행이 가능한 상태로 같은 상태의 여러개 프로세스들이 존재할수 있음
- **running** : 프로세스가 CPU를 할당받아 명령어를 수행중인 상태, 일반적으로 CPU가 하나이기 때문에 실행중인 프로세스는 하나뿐
- **waiting(blocked)** : 프로세스가 CPU를 할당 받아도 당장 실행 할 수 없는 상태, 현재 프로세스가 I/O작업 등을 처리중인 상태
- **terminated** : 프로세스의 실행 종료, 프로세스의 실행이 완료되고 할당된 CPU를 반납, 커널공간내의 PCB는 남아있음
- 프로세스가 만들어지는 과정의 상태가 new이고 프로세스가 다 수행되어 종료될때 잠시 생기는 state가 terminated이다. 즉 new하고 terminated는 운체가 프로세스를 만들거나 종료시킬때 잠시 임시적으로 있는 state를 말하고 이외의 3개의 상태가 돌아가면서 프로세스가 수행된다.

### 프로세스의 상태전이
- **new => ready** : new 상태에서 OS에 의해 승인을 받아 프로세스가 생성되면 해당 프로세스의 PCB(Process Control Block, 커널 내 자료구조)이 OS커널의 Ready Queue에 올라옴
- **ready => running88 (dispatch)** : Ready Queue에 있는 프로세스들 중에서 스케줄링 알고리즘에 의해 선택받은 프로세스가 CPU를 할당받음
- **running => ready (timer interrupt)** : CPU를 할당받아 일을 하다 특정 이유로 다른 프로세스에게 CPU를 주고 다시 CPU를 기다림
- **running => waiting** : 현재 CPU를 받아 명령어를 수행중인 프로세스가 I/O 작업을 해야하는 경우로 CPU를 반납하고 해당 장치 큐에 들어가게 되며 이 상태를  blocked 상태라 함
- **waiting => ready (wake-up)** : I/O 작업을 위해 장치 큐에있던 프로세스가 디스크 컨트롤러에 의해 서비스를 받아 일을 하고 디스크 컨트롤러가 인터럽트를 발생하여 프로세스가 한 일을(로컬버퍼에 저장된 데이터) 메모리에 올려놓고 프로세스는 다시 Ready Queue에 들어가게 됨 
- **running => terminated** : 프로세스 실행이 완료되어 자원을 반납한 상태
## 프로세스의 메모리 구조
운영체제는 프로그램을 실행하기위해 메모리를 할당 한다. 그 구조는 아래 그림과 같다.
![프로세스 메모리 구조](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fcqk9Wt%2Fbtq9Rehkwfd%2F6QNk4WEKb7O7JR4TvXakvK%2Fimg.png)
- **Code 영역** : 프로그램 명령이 위치하는 곳으로 기계어로 제어되는 메모리 영역
- **Data 영역** : 프로그램이 실행될 때 생성되고 프로그램이 종료되면 시스템에 반환되며 전역변수, 정적변수, 배열, 구조체 등이 저장된다.
- **Heap 영역** : 필요에 의해 메모리를 동적 할당하고자 할 때 사용하는 메모리 영역으로 동적 데이터 영역이라고 부른다. 메모리 주소 값에 의해서만 참조되고 사용하는 영역
- **Stack 영역** : 프로그램이 자동으로 사용하는 임시 메모리 영역으로 지역변수, 매개변수, 리턴 값 등이 잠시 사용되었다가 사라지는 데이터를 저장하는 영역 으로 함수 호출 시 생성되고 함수가 끝나면 반환된다. Stack 사이즈는 각 프로세스마다 할당되지만 프로세스가 메모리에 로드될 때 Stack 사이즈가 고정되어 있어 런타임 시 Stack 사이즈를 바꿀 수 없다.
- Stack의 지역변수는 사용하고 소멸하므로 데이터 용량이 불확실하다. 그렇기 때문에 밑에서부터 채워올리고 Heap은 위에서부터 채워나간다. 이렇게 서로 주소값을 채워나가다가 Heap에서 Stack 방향으로 영역을 침범하는 경우 HEAP overflow라고 하며 반대로 Stack에서 Heap 방향으로 영역을 침범한다면 STACK overflow라고 한다.
# 스레드란?
그렇다면 스레드란 무엇일까? 드디어 내가 알고싶었던 목표에 도착했다. 
> 프로세스가 할당 받은 자원을 이용하는 실행 단위로 프로세스는 최소 한 개 이상의 스레드를 가진다.

스레드는 프로세스안에 있는 하나의 실행 단위로 경량화 프로세스라고도 부른다.
종합 해보면 보통 하나의 프로그램은 하나 이상의 프로세스를 갖고 있으며 하나의 프로세스는 반드시 하나 이상의 스레드를 갖고 있다. 프로세스를 생성하면 기본적으로 하나의 메인스레드가 생성된다. 
![메모리 관점에서 본 프로세스와 스레드](https://miro.medium.com/max/700/0*39Jqwl1DcgCaTEGr.png)
위 그림은 스레드의 구조를 표현한 것이다. 스레드는 프로세스 내에서 스택 영역만 별도로 할당받고 부모 프로세스의 Code, Data, Heap영역은 공유한다. 따라서 프로세스 내의 자식 스레드들은 서로 주소공간이나 자원을 공유하면서 실행될 수 있다.
# 멀티프로세스와 멀티스레드
두 개념을 비교하기 위해서는 한 프로그램의 처리방식이라고 생각하는게 이해하기 편하다.
## 멀티프로세스
>멀티프로세스는 하나의 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.

![멀티프로세스](https://miro.medium.com/max/700/0*Ckn6QtkZgOQ2m1xO.png)

### 멀티프로세스의 특징
- 각각 독립적인 메모리구조를 가지기때문에 여러개의 자식 프로세스 중 하나에 문제가 발생하더라도 다른 프로세스에 영향이 없다.
- 프로세스간 공유하는 자원이 존재하지 않아 동일한자원에 동시접근해서 발생하는 dead lock 문제에서 비교적 안전하다.
- 멀티스레드에 비해 구현이 간단하다.
- 독립된 메모리 영역이기 때문에 작업량이 많을수록( Context Switching이 자주 일어나서 주소 공간의 공유가 잦을 경우) 오버헤드가 발생하여 성능저하가 발생 할 수 있다.
- 프로세스마다 각각 독립된 메모리 공간을 할당해야 하므로 불필요한 메모리 사용량이 많다.
- 프로세스 간 통신을 하기 위해 IPC를 통해야 하는데 이 경우 오버헤드가 발생한다.
## 멀티스레드
멀티 프로세스의 특징은 유지하면서 멀티프로세스가 가진 단점들을 극복하기 위한 방법으로 등장했다.
> 하나의 응용 프로그램을 (한 프로세스에) 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하도록 하는 것
### 멀티스레드의 특징
- 스레드들은 부모 프로세스의 자원과 메모리를 공유할 수 있기에 스레드 간 자원 공유가 쉽다.
- 새로운 프로세스를 할당하는 것보다 새로운 스레드를 할당하는 것이 더 비용이 적다.
- 프로세스의 메모리를 공유하기 때문에 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.
- 스레드간의 자원은 공유가 가능하기때문에 자원의 동시접근발생오류 DeadLock이 발생할수있다.
- 논리구조 설계및 디버깅이 어려워 구현난이도가 증가한다.

## 멀티프로세스와 멀티스레드 비교
자원의 효율성 측면
멀티스레드는 프로세스 내 자원을 공유하기 때문에 멀티프로세스에 비해 시스템 자원 소모가 줄어든다.

응답시간과 처리비용 측면
프로세스간 IPC를 사용하는 것은 비용이 크다. 스레드의 경우 공유자원의 이용을 통해 스레드간 통신의 비용이 적다. 또한 프로세스 간 문맥교환은 스레드 간 문맥교환보다 느리다. 그 이유로 스레드는 문맥 교환 과정에서 Stack영역만 처리하면 되기 때문이다.

안정성 측면
멀티스레드가 동일한 공간을 공유하면서 생기는 임계영역 문제가 있다. 멀티프로세스의 경우 프로그램의 문제가 생기면 프로그램을 중단시키고 다시 시작하면 되지만 멀티스레드 방식의 경우에는 하나의 스레드가 공유공간을 망가뜨리면 해당 공간을 공유하는 모든 스레드를 망가뜨릴 수 있다.
# 마무리
발표준비를 위해 준비한 자료였지만, 발표를하며 부족했던 내용들이 많아 글을 쓰면서 많이 보충해 두었다. 그리고 이 기회로 프로그램 ⇒ 프로세스 ⇒ 스레드의 상관관계를 이해하고 멀티프로세스 와 멀티스레드의 차이를 이해 할 수 있었다. 
## 참고자료
[https://www.youtube.com/watch?v=iks_Xb9DtTM](https://www.youtube.com/watch?v=iks_Xb9DtTM)
[https://www.youtube.com/watch?v=1grtWKqTn50](https://www.youtube.com/watch?v=1grtWKqTn50)
[https://www.youtube.com/watch?v=w_M7To_N_jY](https://www.youtube.com/watch?v=w_M7To_N_jY)
[https://recorda.tistory.com/entry/20160503프로세스-메모리-구조](https://recorda.tistory.com/entry/20160503%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0)
[https://velog.io/@raejoonee/프로세스와-스레드의-차이](https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4)
[https://aronglife.tistory.com/entry/NetworkTCPIP-멀티스레드1스레드의-이해](https://aronglife.tistory.com/entry/NetworkTCPIP-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C1%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%9D%B4%ED%95%B4)
[https://charlezz.medium.com/process와-thread-이야기-5b96d0d43e37](https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37)
[https://kosaf04pyh.tistory.com/190](https://kosaf04pyh.tistory.com/190)
[https://velog.io/@koreanhole/프로세스와-스레드](https://velog.io/@koreanhole/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C)