# 3-way-handshake란?

## 3-way-handshake를 알기전에 간단히 tcp/ip의 흐름을 살펴보자!

![image](https://user-images.githubusercontent.com/70435257/128877854-f5c1ec29-1834-433f-92ed-58fdce65a841.png)

이 5가지 계층중에서 전송계층은 응용층에 서비스를 제공하는 책임이 있다.

이때 사용되는 프로토콜이 바로 tcp와 udp이다. 3-way-handshake를 알아보는 시간이므로 tcp에 대해서만 간략하게 알아보자!

---

## 전송층의 프로토콜 맛보기!

![img](https://lh5.googleusercontent.com/nbmvjWSXKsLlVi9-L9cpCFzz_4N5xQepz8kBdzYwhEOkLNbusyRs5qd9_vzPrLo9Z38qSxiuqdB59ucyJgUGYvMiA8aWwb9E7oQQ_MHYzWWT7B128DNWsUGPkxx2oIVz5U_JnVP1Lh0)

위와 같이 SCTP, TCP, UDP 세개의 프로토콜을 확인할 수 있다.

- SCTP

  - UDP와 TCP의 특성을 결합한 새로운 전송층 프로토콜이다.

- TCP
  - 신뢰성이 중요한 어떤 응용에 의해 사용될 수 있는 신뢰성이 있는 연결-지향 프로토콜이다.
- UDP
  - 단순성과 효율성으로 사용되는 신뢰성이 없는 비연결 전송층 프로토콜이다.
  -

## 데이터 전송하기

tcp는 연결지향 프로토콜이다. 따라서 A에서 B사이트 사이의 데이터를 전송하면

1.  2개의 TCP는 두 사이트 사이에 연결을 설정한다.
2.  양 방향으로 데이터를 교환한다.
3.  연결이 종료된다.

위와 같은 과정으로 진행이 된다. 하지만 이는 물리적 연결이 아니라 가상으로 된 연결이다.

따라서 TCP 세그먼트는 IP데이터그램으로 캡슐화되고, 순서가 뒤바뀌는 경우와 손실 또는 훼손되어 전달될수 있으며 이럴 경우 재전송된다.

세그먼트들은 다른 경로를 사용할 수 있지만 바이트들을 순서대로 전달하는 책임이 있는 스트림 지향환경을 만든다.

---

## 그렇다면 어떻게 연결을 보장할까?

우선 TCP 세그먼트 형식을 보자

![image](https://user-images.githubusercontent.com/70435257/128877972-f88634e2-c81a-4d45-b5c8-14e69270291b.png)

위는 실제 세그먼트 형식이다. 세그먼트는 손실되고 손상되었다면 TCP는 잃어버린 세그먼트가 도착할 때까지 세그먼트를 유지한다.(IP는 이 사실을 모른다.)

여기서 중요한것은 순서번호와 ack이다.

- 순서번호
  - 순서번호는 세그먼트에 포함된 첫 번째 데이터 바이트에 할당된 번호를 정의한다.
  - TCP는 연결성을 확신하기 위해서 전송되는 각 바이트에 번호가 부여된다.
- ACK
  - 세그먼트의 송신자가 다른 쪽으로부터 받기를 기대하는 바이트의 번호를 정의한다.
  - 세그먼트 수신자가 상대방으로부터 바이트 번호x를 성공적으로 수신하였다면 x+1이 확인응답번호가 된다.
  - 피기백될 수 있다.

TCP는 전이중 모드로 데이터를 전송한다. 따라서 2개의 시스템에 있는 2개의 TCP들이 연결될 때 동시에 서로 세그먼트를 송신할 수 있다.

이것은 양쪽이 각각 통신을 초기화해야하고, 데이터를 전송하기 전에 다른 쪽으로부터 승인을 얻어야 한다는것을 의미한다.

## 이제 3-way-handshake에 대해 알아보자!

클라이언트가 서버와 연결을 만들기를 원한다고 가정하자!

1.  서버

    - 우선, 서버가 먼저 TCP에 연결을 받아들일 준비가 되었다고 알린다. 이것을 수동개방요청이라고 한다.

    - 서버 TCP는 세상에 있는 어떠한 컴퓨터로부터도 연결을 받아들일 준비가 되어있지만 스스로 연결을 유지할 수 없다.

2.  클라이언트

    - 클라이언트는 능동 개방요청을 유발한다.
    - 클라이언트는 특정한 서버에게 연결이 필요하다는것을 자신의 TCP에게 알린다.

3.  이때 3-way-handshake절차를 시작한다.

![image](https://user-images.githubusercontent.com/70435257/128878062-85bb746d-a130-4981-a518-9610ff4e5756.png)

1.  클라이언트는 SYN 플래그만 설정되어있는 첫 번째 세그먼트인 SYN세그먼트를 전송한다.

    - 이것은 순서번호들의 동기화를 위한 것이다.
    - 처음 순서번호로 랜덤 번호를 선택하고 이 번호를 서버에게 전송한다. ( 이번호를 ISN이라 부른다.)
    - 실제 데이터를 운반하지 않는다.

2.  2개의 플래그 비트가 설정된 두 번째 세그먼트인 SYN + ACK 세그먼트를 전송한다.

    - 이 세그먼트는 이중의 목적을 가지고 있다.
      1. 서버로부터 클라이언트로 전송된 바이트의 번호를 위한 순서번호를 초기화 시키는 용도
      2. ACK 플래그를 설정하고 클라이언트로부터 수신이 예상되는 다음 순서번호를 표시함으로써 클라이언트로부터 SYN 세그먼트의 수신을 확인응답한다.
    - 데이터를 운반하지 않는다.

3.  클라이언트가 세번째 세그먼트를 전송한다.

    - ACK 세그먼트만 보낸다.
    - ACK 플래그와 확인응답 번호 필드를 사용하여 두 번째 세그먼트를 수신한 것에 대한 확인응답이다.
    - 이때 데이터가 없다면 client는 순서번호를 보내지 않고 ACK만 보낸다.

---

### MSS

- MSS (Max Segment Size)인데, 이것은 TCP가 한번에 보낼 수 있는 최대의 데이터 량을 의미한다.

- 5000byte 파일을 전송하는 경우 MSS가 100byte라면, 50개의 세그먼트를 생성해야한다.

- 이때 TCP는 각 세그먼트의 sequence NumberField에 Byte기준 번호를 붙인다. ex) 첫번쨰가 0이라면 두번째는 100, 세번쨰는 200 이다.

- ack번호는 다음데이터의 sequence Number이기 때문에 첫번째 세그먼트를 보냈다면 수신자는 0~99번까지의 데이터는 잘 도착했기 때문에 99+1인 100의 번호로 응답한다.

- 수신자 측에서는 0 ~ 99까지의 sequence number와 200 ~ 299까지의 세그먼트를 받았다면 중간 데이터를 받지 못했다. 따라서 ack number 100으로 응답할 수 있다. 이러면 발신측에서는 재전송할 수 있다.

## SYN Flooding 공격

- ### 정의

  - 악의적인 공격자가 데이터그램에 있는 근원지 IP주소를 위조하여 서로 다른 클라이언트로부터 SYN 세그먼트가 들어오는것처럼 가정하고 대량의 SYN 세그먼트들을 서버에게 송신할때 발생한다.
  - 이떄 TCP서버는 SYN + ACK 세그먼트들을 위조된 클라이언트에게 송신을 한다. 이떄 물론 가짜이므로 모두 손실이된다.
  - 하지만 이동안 많은 자원이 사용되지 않고 점유된다.
  - 이것이 서비스 거부공격의 보안 공격 형태에 속한다. (denial of service)

- ### 예방방법

  - 특정 시간동안 연결 요청수에 대해 제한을 한다.
