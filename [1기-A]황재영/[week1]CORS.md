# 서론

예전에 `CORS` 문제를 겪어봤었어요. 당시 전 일주일 채 되지 않던 웹개발 공부하는 코린이였고, 문제를 해결하는 대신 문제를 제거하는 방식으로(?!) `CORS`를 해결해버렸죠.

언젠가 꼭 다뤄봐야겠다고 생각했는데, 그게 오늘이 됐네요. 😂  
그렇다면, 이제 시작해볼까요 !

# CORS란?

먼저 용어를 살펴봅시다. 대문자로 쓰여진 걸 보니, 뭔가에 대한 줄임말일 거에요!

`CORS`란 `Cross-Origin Resource Sharing`의 약자에요. 뭔가 언뜻 보면 이게 무슨 🐶소리지 싶은데, 하나씩 뜯어볼까요?

- `Cross-Origin` 교차 출처. 즉 출처가 서로 다르면!
- `Resource` 자원의
- `Sharing` 공유에 대한

그런 부분을 제어하는 정책이겠죠?!

그리고 뜻은 모질라(이하 모선생님)께서 말씀해주시기로는 다음과 같다고 해요.

> CORS는 **추가 `HTTP Header`를 사용**하여 한 출처에서 실행 중인 웹 애플리케이션이 **다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여**하도록 브라우저에 알려주는 체제

그렇다면 우리가 **의문점을 가질 부분은 크게 3가지**일 것입니다.

> 💡
>
> 1. **굳이 CORS가 있어야 돼?** (존재 자체에 대한 의문)
> 2. **출처, 자원이란 무야?** (개념 자체에 대한 의문)
> 3. **어떻게 제한하고, 이를 어떻게 해결해야 해?** (과정에 대한 의문)

더 많은 의문점이 있겠지만, 아쉽게도 이 글은 이 3가지에 초점을 맞췄어요.

만약 더 궁금하거나 덧붙이고 싶으신 점이 있으시다면, 의견과 정보를 공유하는 건 어떨까요?!

---

# 1. 굳이 CORS가 있어야 돼?

> ⭐ **보안을 위해서 필요합니다!**

## SOP(Same Origin Policy)

우리가 강도가 들어왔다면 어떻게 하죠? 저라면 프라이팬으로 냅다 후려칠 거에요.

네, 누군가 허락 없이 들어왔다면 우리는 이걸 막아야겠죠. 이에 관한 보안 정책이 바로 `SOP`라는 겁니다. 그냥 아무도 못 들여 보내주는 거에요. **같은 출처만 사용하게 한다!**

만약에 해커가 공격용 `URL`을 심었고, 사용자가 클릭했을 때 해당 `URL`이 열려서 해커가 이를 조작하여 서버에 요청을 한다고 생각해봅시다. 그렇다면 만약 `CSRF(Cross-Site Request Forgery)`, `XSS(Cross-Site Scripting)`에 대한 보안이 약하다면 이를 그냥 허용하겠죠.

이러한 것들을 막는 것이 `SOP`입니다. 이를 위반하면 못 사용하게 하는 거죠.

> ###💡 **그런데... 착한 애들도 있잖아요?! 🥺**

그런데 만약, 제가 친구한테 집을 초대했는데, 가족들이 친구들을 쫓아내면 어떨까요? 기분이 상하겠죠? **네, 분명 우리 자원을 공유하고 싶은 착한 친구들도 존재한단 말이죠.**

> 💡 **이것이 CORS가 등장한 배경이죠!!!**

자동문을 생각해볼까요? 일단 어쨌든 쉽게 열 수 있지만, 우리는 자동문이 있기에 일단 현관에 기다리기도 하고, 이곳에 대한 경계를 형성할 수 있어요. 또한, 인터폰을 누르게 함으로써 최소한의 신원도 확인하게 되죠.

즉, **다 들여보낼 수는 없지만, 그래도 네가 우리 절차만 지켜준다면, 우리도 어느정도 자원 사용은 허락해줄게!가 바로 `CORS`**입니다.

---

# 2. 출처, 자원이란 뭘까요?

저는 일단 뭔가 정의를 이해하기 위해서는 그전에 선행해야할 지식들을 먼저 알고 넘어가는 걸 선호합니다.

따라서 **이번 `CORS`를 봤을 때, 출처, 자원에 대한 이해는 있어야겠다고 생각했어요.** 잠깐 이를 간단하게 짚고 넘어가봅시다!

### 출처

![https://evan-moon.github.io/static/e25190005d12938c253cc72ca06777b1/d9199/uri-structure.png](https://evan-moon.github.io/static/e25190005d12938c253cc72ca06777b1/d9199/uri-structure.png)

뜬금없기는 하지만, **블로그**를 생각해봅시다

> A: **스크랩 시 꼭 댓글로 퍼간다는 말을 해주세요! 불펌 금지!**  
> B: **잇님~ 퍼가요~~~**  
> C: **(불펌)**

한 번쯤 이런 글들, 상황을 보셨을 거라 생각해요. 출처는 이를 통해 굉장히 쉽게 알 수 있어요.

> **제공하는 곳도 출처를 밝혀서 제공**하며(게시),  
> **제공 받는 곳도 어떤 정보를 받는 곳에 대한 출처**를 작성한 거죠!(퍼가요)

그리고 이 출처는, 생각보다 디테일한 걸 요구하지 않아요.  
집을 예시로 들어볼까요?

택배기사는 XX시 XX구 XX동 XXX아파트 XXX동 XXXX호라는 **집 주소**를 원하지, 거실, 욕실, 베란다, 부엌 등까지의 **디테일한 좌표, 위치 정보를 원하지는 않거든요.**

그렇다면, **어떤 게 필요하고, 어떤 게 필요하지 않은지**를 알아야겠죠?  
출처는 일치 여부를 **다음 3가지**를 보고 유효성을 판단해요.

- **`Protocol`이 같은지**
- **`Host`가 같은지**
- **`Path`가 같은지**

뭐, "우리집은 거실이 있어!"라고 말했다고 듣는 사람이  
거기 "우리 집이야!"라고 말하는 사람은 없는 것과 마찬가지겠죠?!

그렇다면 **기타 정보**는 `Path` (경로) `Query String` (쿼리) `Fragment`가 되겠죠.

> **여기서, 굳이 출처에 대한 일치성 검사 없이 옛다~ 💩 받아라~하는 곳이 있어요.  
>  그곳은 바로 IE....  
> <수정: 검사는 하는데, `PORT` 번호는 따로 검사를 하지는 않는다고 하네요!>**

<br/>

### 자원

우리가 집에 돌아가면, 결국 잘 수 있는 공간과 먹을 수 있는 공간 등, 집에 있는 것들을 통해 저희의 삶을 윤택하게 할 수 있죠. 우리는 이를 좀 더 하드하게 얘기하면 **자원을 사용**하는 거죠.

따라서 웹 브라우저에서 리소스란 다음과 같은 것을 지칭해요.

**HTTP 요청으로 가져올 수 있는 모든 종류의 파일**을 말합니다. 대표적으로 **HTML, CSS, JS, 이미지, 비디오 파일 등이 리소스에 해당**합니다.

---

# 3. 어떻게 제한하고, 어떻게 해결할까?

> CORS는 **추가 `HTTP Header`를 사용**하여 한 출처에서 실행 중인 웹 애플리케이션이 **다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여**하도록 브라우저에 알려주는 체제

브라우저는 말이죠, 정말 하라는 대로 분석을 하죠.

그래서 우리가 만약 어떤 출처를 줬다면 그 `string value`의 피상적인 `string`만 그대로 파싱합니다.

- http://127.0.0.1
- http://localhost

따라서 다음과 같은 세세한 정보마저 **위배했다**라고 판단해요!

## 제한

## CORS의 다양한 시나리오

이렇게 엄격한 브라우저... 실제로 CORS도 어느정도 정해진 3가지 시나리오가 있어요.

놀러 간다고 생각해봅시다. 차를 탈 수도 있고, 지하철도 타면서 목적지에 도착하죠. 마찬가지입니다. `CORS`도 다음과 같은 시나리오들이 있어요

- **단순요청(Simple Request)**
- **사전요청(Preflight)**
- **인증정보 포함 요청**

### 사전 요청 (Preflight)

![https://evan-moon.github.io/static/c86699252752391939dc68f8f9a860bf/d9199/cors-preflight.png](https://evan-moon.github.io/static/c86699252752391939dc68f8f9a860bf/d9199/cors-preflight.png)

> ⭐ **오늘 집에 놀러 가도 되는지 물어볼까!**

자 `Pre` (이전) + `flight`(비행)이죠. 사전에 미리 날려 보내는 겁니다.

이 방식은 다음과 같은 동작 방식을 수행해요.

1. **OPTIONS 메서드**를 통해 다른 도메인의 리소스에 요청이 가능한 지 확인
2. 요청이 가능하다면 실제 요청(Actual Request)를 보냄
3. 요청 수락 → 놀러 간다😝  
   요청 거부 → 흥이다😒

**프리플라이트**는 말이죠, 요청할 때에는 다음과 같은 포맷이 있다고 하네요.

- `**Origin` : 일단 난 이런 사람이거든!\*\*
- `**Access-Control-Request-Method` : 난 이런 걸 원하는데 말야! (메소드 - GET, POST, ...)\*\*
- `**Access-Control-Request-Headers` : 내가 이런 거 들고 갈 건데, 받아주련? (헤더 - Content-Type, ...)\*\*

그렇다면 이를 알려주기도 해야겠죠? 서버 측에서는 👌🏻를 다음과 같이 보내요.

- `Access-Control-Allow-Origin` : 그래, 네가 얘라고?
- `Access-Control-Allow-Methods` : 우리는 이런 옵션들은 허용하고 있어.
- `Access-Control-Allow-Headers` : 이런 거들도 들고 와도 돼
- **`Access-Control-Max-Age`**: **또 물어보면 나도 지금 바빠서, 그냥 이 답변 저장해 놓을게!(캐싱해서 이후 정해진 시간 내에는 자동응답)**

다만 **응답 코드가 200대**여야 하며(나 이거 제대로 처리했다?!),  
**응답 바디는 비어있는 게 좋다**고 합니다. (계속된 질문은 내 에너지를 뺏는다...)

> 💡 **그럼 이거 우리가 조작해야 돼요?!**

모 선생님께서는 우리가 직접 조작하지 않아도 된다네요!

사전 요청은 일반적인 상황에서는 **브라우저에서 자동으로 발생**됩니다. **그러므로 프런트엔드 개발자가 이 요청을 직접 작성할 필요는 없습니다.** 또한 **프리 플라이트 요청이 필요한 경우에만 나타나므로 단순 요청(simple requests)의 경우에는 사전 요청이 생략**됩니다.

> 💡 **장점이 뭐에요 그럼? 그냥 실패하면 실패한 거지...**

그것은 **브라우저가 `CORS`를 관리한다는 맹점**에서 중요성을 느낄 수 있답니다 😂  
**만약에 `CORS`를 모르는 서버가 있다고 가정**을 해봅시다! 그러면 다음과 같은 동작 순서가 발생해요.

> 1.  **브라우저:** 야! 내놔
> 2.  **서버:** 네...네넵....
> 3.  **브라우저:** 응? 이거 문제 있네, 그냥 취소한다~
> 4.  **서버:** ????

이게 지금 이렇게 보면 단순합니다. 하지만 **최악의 경우**를 살펴봅시다. `**DELETE` 메서드로 삭제\*\*를 한다면 어떻게 될까요?

> 1.  **브라우저:** 야! 삭제해! 일해라!
> 2.  **서버:** 네...네넵...
> 3.  **브라우저:** 야 미안 이거 알고 보니 문제 있었어 ㅋㅋㅋㅋㅋ
> 4.  **서버:** ??????🔥🔥🔥

네, **서버의 처리와 별도로 결국 브라우저의 응답이 이루어져요.**  
따라서 이를 해결하는 것이 사전 요청이기에 꼭 알아둬야겠죠?!

### 단순 요청(Simple Request)

> 💡 **야! 알지?! 기본 양식대로 일단 보낸다?**

이 친구는 쿨합니다. 그냥 보내고 확인해요. 쉽게 말하면 갑자기 놀러왔다고 냅다 집을 두드리는 거죠.

대신에 어느 정도 **절차는 지켜주는 애**입니다. **다음 3가지 조건을 만족**해요.

1. `**GET` `POST` `HEAD`\*\* 메서드여야 해요. (집에 오는 목적이 항상 같다고 이해하면 되겠죠?)

2. `**Content-Type**`은 (내가 보통 이걸 헤더에 담아서 가면, 이런 형식들만 들고가!)

   - **application/x-www.form-urlencoded**
   - **multipart/form-data**
   - **text/plain**

3. `**Header**`는 (들고 갈 게 뭔지 알려줄게!)
   - **Accept**
   - **Accept-Language**
   - **Content-Language**
   - **Content-Type**

가 있어야 해요.

이러한 요청을 브라우저 입장에서 **안전한 요청**이라고 한답니다!

### 인증 정보 포함 요청 (Credentialed Request)

**인증 관련 헤더를 포함할 때 사용**합니다. 결국 좀 더 까다롭게 인증 절차를 거쳐야 하는 곳에서는 이를 요청해야 할 수 있어요!

- **클라이언트 측**

  헤더에 `credentials: include`를 설정을 해주고요!

- **서버 측**

  `Access-Control-Allow-Credentials: true`가 되어있어야 하겠죠?!

  이때, `Access-Control-Allow-Origin: *`는 쓸 수 없다고 하네요!

---

## 해결 방법

사실 지금까지도 직접 헤더에 설정해서 해결했어요.

1. **프록시 서버 설정**

   먼저, 우리의 브라우저가 웹 환경에서 클라이언트 역할을 하고 있죠?

   그리고 요청에 대한 응답에는 프론트 서버와 백엔드 서버로 나누어지구요.

   일단 우리의 브라우저에서 요청할 때, 프론트 서버에서는 백엔드에 `Origin`을 보낼 거에요.

   이때 프록시 서버는 이 `Target`을 슬쩍 바꿔주는 거에요.

   사실 `CORS`란 건 **브라우저에서 발생하는 정책**이기 때문에, 이렇게 **바뀌어서 전달된** **`Origin`은 같은 오리진으로 판단**시키는 거죠!

2. **직접 헤더에 설정**

   서버에서 직접 헤더를 설정해주면 되겠죠?!

   사실 `CORS` 문제는 **프론트엔드 개발자가 아무래도 `API`를 요청**했을 때 마주하기에 고충은 저희에게 있지만, **결국에 백엔드 서버에서 이를 허용**시켜야 해요.

   **따라서 결국에는 커뮤니케이션이 중요하다고 할 수 있겠습니다 :)**

---

# 참고자료

1. [리소스에 관한 정보 - Toss](https://toss.tech/article/smart-web-service-cache)
2. [가장 좋다고 생각하는 블로그 내용](https://evan-moon.github.io/2020/05/21/about-cors/)
3. [CORS에 관한 정보(블로그)](https://vvshinevv.tistory.com/60)
4. [사용 주의사항](https://velog.io/@logqwerty/CORS)
5. [https://ko.javascript.info/fetch-crossorigin](https://ko.javascript.info/fetch-crossorigin)
6. [[유튜브 영상]](https://www.youtube.com/watch?v=-2TgkKYmJt4)(참고하기 좋았다)
