# 시작하며 🌈

저는 항상 프로토타입이라는 말을 들으면 굉장히 뭔가 이런 느낌에 사로잡혀요.

> **뭔가 숨겨진 것을 건드리는 듯한 느낌  
> 그래서 뭔가 이해할 것 같으면서도, 이해하기 힘든 느낌**

최근에도 강의를 듣는데, 그래서 저게 어떻게 동작했더라...?라고 생각하니, 가물가물~ 하더라구요.

그래서 스터디 주제로 선정했습니다.

> **이 글은 그래서, 스터디이자, 까먹은 사람의 반성이 담긴 글입니다.  
> 이제 반성문 썼으니, 안 까먹겠죠...?!** ~~(팩트: 사람은 고쳐 쓰는 게 아니라더라)~~

# 목차 📃

이 글은 다음과 같이 7분에 맞춰 구성을 도전(?)해봤어요.  
너무나 방대한 개념이라, 아마 다음 주도 이걸 좀 더 풀어서 설명할 듯 합니다!!!

오늘은 맛만 보자구요!

워낙 부족한 글이기도 하고 (실제로 개념 이해 및 정리가 잘 안 돼서 지금 **4번째** 엎었어요...)  
**서로 알고 있는 프로토타입에 대한 개념을 의견으로 나누는 것도 좋을 것 같아요 :)**

1. **프로토타입이 그래서, 뭐야? (정의)**
2. **실제로 프로토타입이 어떻게 이루어져? (과정)**
3. **그럼, 이걸 어떻게 활용할까? (필요성 및 응용)**

---

# # 1. 프로토타입의 정의

> **삐빅! 꽤나 글로만 서술되어 있습니다. 지겹다면 빨리 나가시길 바랍니다! 🖐🏻**

일단 프로토타입을 주제로 삼았는데, 사실 저도 정의를 몰라요(?!) 막상 떠올리니 기억이 가물...
그래서 검색해보자구요. **프로토타입은 도대체, 뭘 의미할까요?**

## 구선생님께 그래서 검색해봤어요. 프로토타입은 뭐죠?

![프로토타입이란](https://images.velog.io/images/young_pallete/post/26626e18-c483-413b-97ac-ca467b6b44cd/Untitled.png)

**엑, 원기라니, 겁나 있어 보이는군요? 그런데, 그래서 뭐냐고요...**

우리의 구 선생님은 정말 깔끔한 한마디로 남겨주셨어요.  
이것이 자생력을 위한 구선생님의 수업일까요?

하지만 저는 정말 머리가 나쁜 학생이라 굉장히 이해하기엔 너무 하드한 느낌이에요.  
그래서 **어떻게 하면 프로토타입의 느낌을 딱! 살릴 수 있을까?** 하고 찾아보니 이런 말이 있었어요.

> **"프로토타입은 쉽게 말해서 유전자다"** -이 시대 최고의 체대 출신 코더 "[미토콘트리트](https://miticoncrete.tistory.com/9)" 선생님 (이름마저 미토콘드리아를 닮았군요!)

저 말을 듣고 **아?!** 싶었어요.

재영이라는 객체가 있다고 해봅시다. **재영은 어떤 속성과 동작을 가지고 있어요.**
예컨대 **이 친구는 저녁에 치킨을 먹을 때는 아무 것도 눈에 뵈지 않는다고 합니다. (죄... 죄송해요😅)**

그런데 이 친구한테는 자식이 있었는데, 자식은 10년간 같이 치킨을 먹으면서 따라했어요.

---

# # 2. 프로토타입의 실제 과정

## 프로토타입의 생성 과정

그렇다면 우리는 사실 이게 가장 생소할 거에요. (이제는 아니신 분들도 계시겠지만요!)

> **우리는 분명 유전자를 따로 구현하지 않았는데...?**

이에 관해서 저도 궁금해서 좀 찾아 봤는데, 다음과 같은 말이 있었어요.

> `const a = {};` 라는 코드가 있다고 한다면, 이것이 `{}`로 생성될 수 있는 이유는
> 이는 내부에서
>
> ```
> const a = new Object();
> ```
>
> 로 인식하면서 생기게 된 결과물이다.

오! 역시 자바스크립트는 정말 편리한 언어가 맞네요.  
그렇다면, 우리의 얘기는 이제 다음으로 치환할 수 있을 것 같아요.

> **우리는 분명 유전자를 따로 구현하지 않았는데...?  
> → Object()에서는 도대체 무슨 일이 벌어지는 거지...?!**

이 구현 과정을 좀 더 살펴봅시다!  
어떤 책에서 저도 이 과정을 알게 됐는데요!

이 `Object`라는 애는 **`OrdinaryObjectCreate` 라는 추상 연산을 반환**한다고 하네요.
그리고 이 연산은 `ECMA-262`에서 다음과 같이 정의되어 있어요.

9.1.12 **OrdinaryObjectCreate ( proto [ , additionalInternalSlotsList ] )**
The abstract operation OrdinaryObjectCreate with **argument proto (an object or null)** is used **to specify the runtime creation of new ordinary objects.** The optional argument **additionalInternalSlotsList** is a List of the names of **additional internal slots that must be** **defined as part of the object, beyond [[Prototype]] and [[Extensible]].** If the list is not provided, a new empty List is used. This abstract operation performs the following steps:

Let internalSlotsList be « [[Prototype]], [[Extensible]] ».
If additionalInternalSlotsList is present, append each of its elements to internalSlotsList.
Let O be ! MakeBasicObject(internalSlotsList).
Set O.**[[Prototype]] to proto.**
**Return O.**

예... 다 알아들으셨죠?!

그러니까 `Object()`를 통한 생성 과정은 런타임에서 다음과 같이 동작한다고 해요.

1. 일단 **새로운 객체를 하나 생성**한다! (`proto` 파라미터에서 받는 인자가 객체든 null이든)
2. 새로운 객체에다 **런타임 생성 시 구체화시켜준다.** (프로퍼티겠죠?!)
3. 옵션은 뭐 일단... 객체의 부분으로 **추가로 정의 되어야 할 내부 슬롯**을 만들어주는 거다!
4. 옵션이 없다면 빈 리스트를 사용하고, **결국에는 추가 옵션 연산 후 `[[Prototype]]`을 넣어주고 반환!**

> 아! 결국에는 쉽게 말해서 객체를 만들었다면! (선언 및 할당을 했다면!)  
> **평가되어 객체로 생성되는 시점에서 프로토타입도 같이 생긴다는 것을 알 수 있습니다 😂**

## 프로토타입은 어떻게 활용되는가?

우리는 생각보다 더 내부적인 부분까지 건드릴 수 있었어요! 👏👏
그런데 사실 지금까지를 보면 이건 의미가 없을 수도 있어요.(응?)

**그래서 우리가 원하는 건, 이걸 어떻게 써먹는지에 대한 부분이 아닐까요?! 응용을 할 수 없는 지식은 결국 아무 짝에 쓸모가 없으니까요.**

그렇다면 저희는 물어봅시다.

> **그렇다면, 이걸 어따가 써먹을까?!**

**깔끔하게 말하자면 프로토타입 체인!이라는 자바스크립트 내부 거대한 시스템에 활용됩니다.**

## 프로토타입 체인은 또 뭐야?!

우리 자바스크립트는 **객체 지향적인 언어**죠? 그리고 한편으로는 프로토타입 기반 프로그래밍 언어라고도 표현을 하죠.

자바스크립트를 만들었던 개발자 중 한명인 더글라스 크록포드 선생님은 다음과 같이 말씀하셨어요.

> **이전 개체를 매개 변수로 사용하고 이전 개체에서 상속된 빈 새 개체를 반환합니다.
> 새 개체에서 구성원을 얻으려고 시도하고 해당 키가 없으면 이전 개체가 구성원을 제공합니다.
> 개체는 개체에서 상속됩니다. 이보다 더 객체 지향적인 것이 어디 있겠습니까?**
>
> \- 더 선생님

또 위키피디아에서 찾아 보면,
**프로토타입 기반 프로그래밍 언어의 특징은 객체를 원형(프로토타입)으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있다**고 합니다.

또 어질어질해졌어요. **복제**는 뭐고, **동작 방식을 다시 사용한다**는 건 뭘까요?

![https://www.howdy-mj.me/static/a88859306abea59f9f7b0277f510fe8c/c1b63/connect.png](https://www.howdy-mj.me/static/a88859306abea59f9f7b0277f510fe8c/c1b63/connect.png)

객체가 생성된다고 하죠?! **그렇다면 일단 생성자 함수에 의해 생성이 된 걸 거에요.**

그렇다면, 이 친구는 프로토타입이라는 다른 객체를 하나 만들어요. 이 친구는 따로 추가된 내부 동작들을 규정할 수 있는 거에요.
예를 들면... `Array.prototype.length`나, `Array.prototype.concat`등과 같이 말이죠!

그렇다면 이 친구는 **나 얘한테서 만들어졌어!라고 하겠죠?!** 그게 **`constructor`** 입니다.
그리고 객체는 이 프로토타입이란 걸 참조함으로써 추가로 구현된 내부 동작 방식을 사용할 수 있는 거에요.

> 1.  **그래서 생성자 함수에서 프로토타입이란 객체를 내부에서 만들어내고 (추상연산)**
> 2.  **결국에는 이 프로토타입에서는 내부 동작을 또 새로 규정할 수 있는 거죠!**

그런데, 또 다른 궁금증이 생겼어요.

**그렇다면, 어떻게 우리는 `Array`와 같은 생성자의 프로토타입 메서드를 쓸 수 있는 건데?!**

그건, 이제 **`[[Prototype]]` 내부 슬롯**에서 도와줘요! 쉽게 말하자면 얘가 부모로 가는 문이거든요!
(정확히 말하자면, 내부 슬롯은 어떤 자바스크립트의 내부 동작 방식을 규정한 의사 메서드에요.  
즉, `[[Prototype]]`은 내부 엔진에게 얘의 부모 프로토타입이 뭐다!를 알려주고 있는 거랍니다.)

![프로토타입상속](https://t1.daumcdn.net/cfile/tistory/999F723359A6C7DE27)

~~**역시 이미지는 복붙해야 제맛...**~~

어떻게 부모에게 가냐구요?
우리는 **`__proto__`라는 정말 신기한 키**를 갖고 있어요.

이 친구는 신기한 역할을 하는데, 우리는 프로토타입에서 이 열쇠를 갖고 **부모 프로토타입으로 가는 문을 딸 수 있어요.** (추상화된 설명인데, 좀 더 풀어서 설명하자면 내부슬롯에 간접 접근해요!)

**프로토타입은 단방향 연결 리스트**에요. 어떤 **참조된 포인터를 갖고 다음 노드로 계속 탐색**할 수 있죠.

따라서, 우리는 계속해서, 이렇게 상위 프로토타입으로 가는 문을 `__proto__`로 따면서, 프로토타입 메서드가 있는지! 계속 탐색하는 거랍니다. 있으면 거기서 메서드를 찾아낼 거고, 없으면 또 따겠죠?!
우리가 쓰는 내장 메서드들이, 이런 식으로 결국 올라가다 보면, 발견이 되어 사용할 수 있는 거에요!

중요한 개념인데, 끝내기 전, 한 번 정리를 해보죠!
**이 3가지만 알면 우리는 프로토타입에 접근하기가 참~편해진답니다.**

1. `prototype` 내 프로토타입이 뭔지 볼까~?
2. `[[Prototype]]` 내 부모 프로토타입은 뭘까~?? (하지만 부모님 문은 닫힘. 볼 수 없다)
3. `__proto__` `[[Prototype]]`에 뭐가 들었는지 따서 볼까~? (일종의 프로토타입 내부 슬롯 열쇠)

아, 실제로 콘솔 창에 다음을 입력해보세요.

```jsx
document.__proto__.__proto__.__proto__.__proto__.__proto__;
```

> **⭐ "환영합니다. 당신은 이제 자바스크립트 객체의 세계의 숨겨진 비밀을 알게 됐습니다."**

---

# 정말 중요한 애구나! 어떻게 써?

~~단도직입적으로 말하자면, 이제는 쓰지 마세요. (응?)
**아니, 정확하게 말하자면 프로토타입의 내부 동작에 지나치게 간섭하는 건 자제해야 해요.**~~

자바스크립트는 직접 프로토타입을 검색할 수도 있고, 참조 및 변경까지도 가능한 대단한(?) 언어에요. **자유도가 정~말 높다는 거죠.**

자유도가 높다는 것들의 장점은 프로그래머의 역량이 좋다면 **구현의 다양성을 충족할 수 있다는 건데 단점은 복잡성을 증가시켜줄 수도 있죠.**

특히 옛날 라이브러리라면, 혹여나 상위 객체의 프로토타입의 메서드를 직접 건드리다가 충돌이 날 수도 있는 노릇이죠. 그럼 정말 내부의 문따고, 문따고... 오류 찾아내고... 아찔하죠?!

또한 지금은 객체에 메서드를 직접 부여 가능한 **클래스와 같은 `syntactic sugar`한 도구들이 있으니, 이런 여러 사람에 의해 검증된 표준 문법들을 사용해보는 건 어떨까요?!**

수정합니다. **사용자가 정의한 생성자 함수를 통해 실제로 프로토타입을 활용해도 좋습니다.**
그렇지만 `Object`와 같이, **표준 객체를 건드리는 건 위험하니 최대한 자제**하라고 하네요.
**오류의 주범이 될 수 있다...! 입니다 😂**

---

# 참고자료

[https://en.wikipedia.org/wiki/JavaScript#Object-orientation\_(prototype-based)](<https://en.wikipedia.org/wiki/JavaScript#Object-orientation_(prototype-based)>)

[http://crockford.com/javascript/prototypal.html](http://crockford.com/javascript/prototypal.html)

[위키피디아 - 자바스크립트(프로토타입 기반 참고)](<https://en.wikipedia.org/wiki/JavaScript#Object-orientation_(prototype-based)>)

[역시 나는 한글 검색파다. 가장 이해가 잘 갔던 블로그](https://medium.com/@bluesh55/javascript-prototype-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-f8e67c286b67)

모던 자바스크립트 Deep Dive 19장

[새롭게 찾아낸 프로토타입의 위험성](http://tcpschool.com/javascript/js_object_prototype)
