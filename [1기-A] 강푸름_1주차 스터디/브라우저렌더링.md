# 브라우저 렌더링 과정

<br>

브라우저는 사용자가 접속한 웹 페이지에 필요한 리소스(HTML, CSS, Javascript, 이미지, 폰트 등등..)를 다운로드 받고 이를 해석하여 화면에 보여준다.

브라우저 렌더링 과정 단계를 크게 `다운로드, 파싱, 스타일, 레이아웃, 페인트, 합성 & 렌더`의 6단계로 나눌 수 있다.

<br>

## 1. 파싱

<br>

브라우저에서 웹 페이지를 로딩할 때 `HTML` 파일을 가장 먼저 다운로드 하는데 이 `HTML`파일을 해석하여 `DOM 트리`, `CSSOM 트리`를 구성하는 단계가 바로 파싱단계 이다.

<br>

### DOM 트리 구성

<br>

파싱이 일어나면 HTML을 해석하여 DOM을 생성하고 각각의 DOM 객체를 트리 구조로 연결하여 부모-자식 관계를 갖도록 만든다. (body, p, div 태그들이 DOM 트리의 노드로 생성되고 자식 노드를 참조하게 된다.

```html
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Browser rendering</title>
  </head>
  <body>
    <p>
      Hello
      <span> web performance </span>
      students!
    </p>

    <div>
      <img src="profile.png" />
    </div>
  </body>
</html>
```

![DOM 트리](https://user-images.githubusercontent.com/35218826/59728721-3422c180-9276-11e9-979f-f79bb3821ef4.png)

<br>

### CSSOM 트리 구성

<br>

CSSOM은 CSS를 파싱하여 그 내용을 트리로 구조화 시킨 것이다. CSSOM이 트리구조인 이유는 `하향식`으로 규칙을 지정하기 때문인데, 하향식이라는 의미는 부모의 속성을 자식이 물려받는다는 의미이다.

HTML 내부에 `style.css` 같은 CSS가 포함되어 있으면 CSS를 해석하여 `CSSOM 트리`를 구성한다. 이 때 HTML에 존재하는 요소들의 선택자 (body, p, div 등등)가 노드로 생성되고 각 노드는 정의된 스타일을 참조한다.

```css
body {
  font-size: 16px;
}

p {
  font-weight: bold;
}

span {
  color: red;
}

p span {
  display: none;
}

img {
  float: right;
}
```

<br>

![CSSOM 트리](https://user-images.githubusercontent.com/35218826/59728723-34bb5800-9276-11e9-9a1e-a4dad5d240fc.png)

<br>

## 2. 스타일

<br>

스타일 단계에서 `DOM 트리`, `CSSOM 트리`를 가지고 렌더 트리를 구성한다. `렌더트리`는 DOM 트리와 CSSOM 트리가 합쳐져 만들어진 트리이며, 최종적으로 브라우저에 표시될 것들로 구성되어 있다.

단, `display: none` 속성이 적용된 요소의 경우 렌더트리에서 제외된다. 하지만 `visibility: hidden` 속성이 적용된 요소는 렌더트리에 존재한다.

그 이유는 `display: none`은 요소 자체가 보이지 않고 공간도 차지하지 않는 반면, `visibility: hidden`은 요소 자체가 보이지 않지만 공간을 차지 하고 있기 때문이다.

<br>

![렌더트리](https://user-images.githubusercontent.com/52060742/128193807-7cf3a740-9c91-4c91-93f1-0a4930f7cfd3.png)

<br>

## 3. 레이아웃

레이아웃 단계는 각 노드들의 정확한 위치와 크기를 계산한다. 이 위치와 크기를 파악하기 위해서 루트노드부터 순회하며 계산된 결과를 `픽셀값`으로 렌더트리에 반영한다.

CSS에서 `픽셀`이 아니라 `%`로 값을 지정했다 하여도 레이아웃 단계를 거친 후에 측정 가능한 `픽셀`단위로 변환된다.

<br>

### 레이아웃 전

![레이아웃 전](https://user-images.githubusercontent.com/35218826/59728724-34bb5800-9276-11e9-8f27-219e65664b66.png)

<br>

![레이아웃 전](https://user-images.githubusercontent.com/52060742/128099617-379d6fbc-3f5a-41be-8f4f-7c36e908af4c.png)

<br>

### 레이아웃 후

![레이아웃 후](https://user-images.githubusercontent.com/35218826/59728725-34bb5800-9276-11e9-9a4e-e26a649523a7.png)

<br>

![레이아웃 후](https://user-images.githubusercontent.com/52060742/128099647-dd357384-3d97-4103-b3cd-9c46f742726d.png)

<br>

## 4. 페인트

<br>

레이아웃 단계에서 계산된 픽셀값을 통해 렌더트리에 있는 각 노드들을 화면상의 실제 픽셀로 변환하는 단계이다. 이 때 크기, `위치와 관계없는 CSS 속성` (색상, 투명도)등을 페인트 단계에서 적용한다. 픽셀로 변환된 결과는 포토샵의 `레이어`처럼 생성되어 개별 레이어로 관리된다.

<br>

```
 레이어  : 렌더링 할 때 페인팅할 대상 영역을 나누어 놓은 것
```

<br>

![레이어](https://sculove.github.io/slides/improveBrowserRendering/image/layercomposite.jpeg)

<br>

## 5. 합성(composite) & 렌더

<br>

페인트 단계에서 생성된 레이어들을 합성하여 실제 화면에 컨텐츠를 그리는 마지막 단계이다. 이 단계가 끝나면 비로소 화면에서 웹 페이지를 볼 수 있다.

```
여기서 좀더 TMI를 추가하자면
렌더링 엔진은 더 나은 사용자경험을 위해 가능한 빠르게 내용을 표시하게 만들어졌습니다.
따라서 모든 HTML 파싱이 끝나기도 전에 이후의 과정을 수행하여
미리 사용자에게 보여줄 수 있는 일부 내용들을 출력하게 됩니다.

 출처: https://boxfoxs.tistory.com/408 [박스여우 - BoxFox]

 정희님 🙏
```

<br>
<br>

# 최적화

<br>

## 1. 블록 리소스 최적화

<br>

HTML을 파싱하면서 `Javascript`와 `css`를 발견하면 파싱을 멈추고 각 리소스를 요청하고 다운로드 한다. 이것을 파싱을 막는 리소스라고 해서 `블록 리소스`라고 하는데, 페인트 단계를 지연시키기 때문에 최적화를 해줘야 한다.

<br>

1.  CSS는 항상 HTML 문서 최상단(`<head> 아래`)에 배치해야 한다.

    ```html
    <head>
      <link href="style.css" rel="stylesheet" />
    </head>
    ```

    그 이유는 렌더 트리를 구성할 때 DOM 트리는 파싱하면서 태그를 만날 때 마다 순차적으로 구성할 수 있지만, CSSOM 트리는 `CSS를 모두 파싱해야` 구성할 수 있기 때문에 최상단에서 파싱할 수 있도록 한다.

    <br>

2.  Javascript는 HTML 문서 최하단(`</body> 직전`)에 배치해야 한다.

    ```html
    <body>
    <div id="kdt">...<div>
    <p id="name">...<p>

    <script src="app.js" type="text/javascript"></script>
    </body>
    ```

    그 이유는 파싱을 하는 과정에서 `<script>`태그를 만나면 스크립트가 실행되는 데, 실행되기 전까지 생성된 DOM에만 접근할 수 있기 때문이다.

    단, 문서 최하단이 아니더라도 파싱을 멈추지 않게 할 수 있는데 `<script>`태그에 `defer` 혹은 `async` 속성을 주면 된다. 하지만 이 속성은 브라우저 지원 범위가 한정적이므로 사용 브라우저를 확인해야 한다.

<br>

- async : HTML을 파싱하는 중에 스크립트를 만나면 파싱하면서 스크립트를 다운받고, 스크립트가 모두 다운로드 되면 스크립트를 실행한다. 실행하는 중간에는 파싱이 잠깐 멈춘다. `주의할 점은 DOM을 조작하지 않는 스크립트에 사용하는 것이 안전하다` . 그 이유는 스크립트에서 아직 `파싱되지 않은 DOM에 접근할 경우 에러가 발생` 하기 때문.

<br>

- defer : HTML을 파싱 하는 중에 스크립트를 만나면 스크립트를 다운로드하지만 바로 실행하지 않고 </html>을 만났을 때(DOM이 모두 파싱 되었을 때) 실행한다. 그래서 DOM을 조작해야 하는 스크립트에서 사용한다.

<br>

```html
<script async src="app.js" type="text/javascript"></script>
<script defer src="app.js" type="text/javascript"></script>
```

> [Can I Use](https://caniuse.com/) : 브라우저별 호환 기능 확인

<br>

## 2. Reflow & Repaint

<br>

브라우저 렌더 과정 중에 `스타일 -> 레이아웃 -> 페인트 -> 합성 & 렌더` 과정을 렌더링 이라고 한다. 이 렌더링은 상황에 따라 반복해서 발생할 수 있다. 이 과정에서 Reflow와 Repaint라는 것이 있는데 이것에 대해 알아보자.

<br>

### Reflow

<br>

어떤 HTML 요소들이 기하학적(`높이, 너비, 위치`) 영향을 받으면 레이아웃 과정을 다시 수행한다. 레이아웃 과정이 수행되므로 요소들의 크기나 위치를 다시 계산하는데 이를 Reflow 라고 한다.

<br>

**Reflow가 발생하는 몇 가지 조건들**

- DOM이 추가,삭제 될때
- 엘리먼트의 기하학적 영향(높이, 넓이, 위치)을 주는 속성이 변경되었을 때
- 브라우저의 viewport(화면) 크기가 변경될 때

<br>

**TMI**

Todo 목록들을 화면에 그려야 하는 상황

```jsx
const todos = [
  { id: 1, content: 'KDT 수료하기' },
  { id: 2, content: '취업하기' },
  { id: 3, content: '여행가기' },
];

// todos가 그려질 컨테이너 엘리먼트
const $todoContainer = document.querySelector('.todo');

// 좋지 않은 방법 -> todos의 개수만큼 Reflow 발생
todos.forEach((todo) => {
  const $todo = document.createElement('div');

  $todo.id = todo.id;
  $todo.innerText = todo.content;

  $todoContainer.appendChild($todo);
});

// 좋은 방법 -> 1번 발생
const template = todos
  .map((todo) => {
    return `
    <div id='${todo.id}'> ${todo.content} </div>
  `;
  })
  .join('');

/* template 의 모습
 * <div id='1'> KDT 수료하기 </div>
 * <div id='2'> 취업하기 </div>
 * <div id='3'> 여행가기 </div>
 */

$todoContainer.innerHTML = template;
```

<br>

### Repaint

<br>

기하학적 영향을 주지 않는 CSS 속성값(`color, background-color 등`)을 변경하면 Reflow 과정을 건너뛰고 페인트 단계부터 수행하는데 이것을 Repaint라고 한다. Reflow과정을 건너뛰기 때문에 성능향상을 기대할 수 있다.

<br>

# 정리

<br>

- `Reflow`가 일어나면 전체 픽셀을 다시 계산해야 하기 때문에 부하가 커질수 있다.
- `Repaint`는 이미 레이아웃 단계에서 계산된 픽셀값을 이용해 화면을 그리기만 하기 때문에 `Reflow`에 비해 부하가 적다.
- `Reflow`보단 `Repaint`만 발생하는 CSS 속성을 사용하는 것이 성능에 좋다!
- 특히, `transform, opacity`같은 속성은 `Reflow`, `Repaint` 과정을 건너 뛰고 바로 `합성 (composite)`단계로 넘어가는데 그 이유는 GPU가 데이터를 가공하기 때문!

<br>

> [Refow, Repaint를 발생시키는 CSS 속성 목록](https://docs.google.com/spreadsheets/u/0/d/1Hvi0nu2wG3oQ51XRHtMv-A_ZlidnwUYwgQsPQUg1R2s/pub?single=true&gid=0&output=html)

> [CSS Trigger](https://csstriggers.com/)

<br>

# 출처

<br>

> [toast ui](https://ui.toast.com/fe-guide/ko_PERFORMANCE#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EB%A1%9C%EB%94%A9-%EA%B3%BC%EC%A0%95)

> [developers.google.com](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko)

> 이미지 - [sculove.github.io](https://sculove.github.io/slides/improveBrowserRendering/#/6)
